### **1 指针、引用和变量名的区别**

指针、引用和变量名都是C++中用于表示数据对象的标识符，但它们有以下区别：

1. 变量名：变量名是标识符的一种形式，用于标识内存中存储的数据对象。通过变量名可以直接访问数据对象。
2. 指针：指针是一种特殊类型的变量，用于存储内存地址。指针变量中存储的地址可以用来访问该地址上的数据对象。指针使用*操作符进行间接

引用。

3. 引用：引用也是一种特殊类型的变量，它相当于给一个已经存在的变量起了一个别名，可以用来修改该变量的值。引用使用&操作符进行声明和

使用。

总的来说，指针和引用都可以用来修改数据对象的值，而变量名只能直接访问数据对象。指针可以指向不同类型的数据对象，而引用只能指向与其

绑定的变量的类型相同的数据对象。

### 2 指针和引用的区别

引用和指针是C++中两种不同的数据类型，它们在使用上有一些区别，如下所述：

1. 指针是一个对象，它存储一个变量的地址，而引用是一个别名，它与变量绑定在一起。引用在内部实现上通常被视为指针，但是它们的使用方式更像变量，因为它们不需要进行解引用操作。

2. 指针可以为空（nullptr），而引用不能。这意味着引用必须在定义时初始化，并始终绑定到一个变量上。
3. 指针可以重新分配和修改，而引用一旦被初始化就不能更改其绑定的变量。这是因为引用实际上是被绑定到变量的别名，而不是一个独立的对象。

4. 指针可以被解除引用来访问其指向的变量，而引用直接访问其绑定的变量。这意味着使用指针时需要进行解引用操作，而使用引用时不需要。
5. 指针可以进行算术运算，比如加法、减法等，以便移动指向的位置，而引用没有这些运算。这也是因为引用实际上是变量的别名，而不是指向变量的指针。

综上所述，指针和引用各有其优缺点，应根据具体情况选择使用哪种类型。在一些情况下，如函数参数传递和返回值，使用引用可以提供更加方便

和清晰的代码；在其他情况下，如需要进行算术运算或者需要动态分配内存等，使用指针是更为合适的。

### 3 函数引用传参、函数调用

```
void func(int& a) {

​    a = 10;

}

int main() {

​    int x = 0;

​    func(x); // 此处传入的是x的引用，即&a

​    cout << x; // 输出10

​    return 0;

}
```

为什么调用时是func(x)而不是func(&x)

如果函数参数是引用类型，可以直接传入变量名作为参数，不需要使用取地址符 &。因为引用类型本身就是一个别名，传入变量名时会自动转换为

对应的引用。

### 4 结构引用传参和结构指针传参的区别

结构引用传参和指针传参都可以用来修改传入的结构体，但两者有以下区别：

1. 使用结构引用传参时，函数参数的类型是结构的引用，也就是`struct MyStruct&`，在函数内部直接对结构的引用进行操作即可，用法和直接对结构进行操作类似，使用起来更加方便和自然。

2. 使用指针传参时，函数参数的类型是结构的指针，也就是`struct MyStruct*`，需要在函数内部使用指针操作符`->`或者`*`来访问结构体成员，用法相对来说比较繁琐，但是可以更加灵活。

总的来说，如果只需要对结构体进行简单的操作，使用结构引用传参会更加方便，如果需要进行更复杂的操作或者涉及到内存管理等问题，使用指针传参可能更加适合。

### 5 1.0f和1.0有什么区别

在 C++ 中，浮点常量默认被解释为双精度浮点数，因此使用 `1.0` 表示双精度浮点数。如果您希望使用单精度浮点数，可以在数字后面添加 `f`，例如 `1.0f`。

在实际应用中，对于单精度浮点数的计算，建议使用 `1.0f` 而不是 `1.0`。这是因为 `1.0` 在计算机内部表示为双精度浮点数，如果使用 `1.0` 进行计算，则需要执行双精度到单精度的转换，这可能会导致精度损失。

### 6 if (NAN==NAN)

ChatGPT

表达式 NAN == NAN 的结果是 false。这是因为NaN 的定义是不是一个数字，它不等于任何数字，包括它自己。这种特殊的比较方式是 IEEE 754标准中 NaN 的定义所决定的。如果需要检查一个值是否为 NaN，可以使用 isnan() 函数，该函数将返回一个非零值（即 true），如果参数是NaN，则返回 true，否则返回 0（即 false）。

### 7 long double和double都是8个字节的情况下，他们是一样的吗

ChatGPT

虽然long double和double都是浮点型数据类型，但是它们的存储方式和精度上有所不同。在大多数平台上，double通常占用8个字节，而long double通常占用12或16个字节，具体取决于编译器和平台的实现。这意味着long double能够表示更大范围的数值，并且通常比double的精度更高。此外，long double在进行浮点运算时所能保留的有效数字位数也更多，因此在需要更高精度计算时，long double通常是更好的选择。

### 8 使用double可以计算最大的阶乘

ChatGPT

使用double类型变量能计算的最大阶乘是170。因为double类型的精度有限，当超过一定值后会出现误差。对于更大的数值计算，可以使用高精度计算库，例如GMP（GNU Multiple Precision Arithmetic Library）。

### 9 delete和delete[]

如果 `end` 是指向数组最后一个元素之后位置的指针，而不是使用 `new` 操作符动态分配的指针，那么在释放内存空间时，我们不应该使用 `delete` 或者 `delete[]` 操作符释放 `end` 指向的内存空间，否则会导致程序崩溃或者其他不可预期的行为。在这种情况下，我们只需要使用`delete[] arr` 操作符释放整个数组所占用的内存空间即可。因此，最终代码可能如下所示：delete[] arr;需要注意的是，在使用 `delete` 或者 `delete[]` 操作符释放内存空间时，我们不需要将指针设置为 `nullptr`。这是因为，在释放内存空间后，指针不再指向有效的内存地址，将其设置为 `nullptr` 可以避免出现悬空指针的问题，但并不是必需的。

### 10 struct exp_st;是结构体的申明还是定义

struct exp_st; 是结构体不完整申明，方便在源文件中修改结构具体内容。main.cpp要使用源文件func.cpp申明的完整结构体，需要包含该源文件#include "func.cpp",否则会编译报错，不建议在一个cpp文件包含另一个cpp文件，可能导致重复定义。所以尽量在头文件给出结构体完整申明

在 C++ 中，声明和定义是的两个不同的概念。声明是指在代码中告诉编译器一个实体的类型和名称，而不进行实际的分配内存或初始化。例如，以下语句就是一个变量的声明：

int x；

这条语句告诉编译器，有一个名为 x 的 int 类型变量，但它并没有分配实际的内存空间。定义则是指在代码中给出一个实体的具体实现，包括分配内存、初始化等操作。例如，以下语句就是一个变量的定义：

int x = 42;

### 11 student* stu = new student[classSize];是什么意思

ChatGPT

这段代码使用了 new 运算符来在堆上动态地分配了一个长度为 classSize 的数组，并将数组的首地址赋值给了指针 stu。该数组中的元素类

型是 student 结构体，因此stu 指向的是一个 student 类型的数组。由于数组是动态分配的，因此数组的长度是在运行时确定的，而不是

在编译时确定的。

请参考//double* arr = new double[MaxSize];指的是将堆上new出来的数组的首地址赋值给指针arr

### 12 student *stu[10]=new student[5]是什么意思（误）

ChatGPT

这个语句会在编译时报错，因为它是错误的语法。数组名和 new 表达式之间不能使用 [] 运算符。如果你想要创建一个包含10个指向

student 结构体对象的指针的数组，你可以这样写：

```
student* stu[10];

for (int i = 0; i < 10; i++) {

	stu[i] = new student[5];

}
```

这个语句将创建一个包含10个指向 student 结构体对象的指针的数组。然后，对于每个指针，它会分配一个包含5个 student 结构体对象的数组。注意，这里的指针数组不需要使用 new 进行分配，因为它是在栈上分配的。只有每个指针指向的数组需要使用 new 进行分配，因为它们是在堆上分配的。

### 13 数组名和指针的区别

ChatGPT

数组名和指针有以下区别：

- 类型不同：数组名是数组类型，指针是指针类型。
- 大小不同：数组的大小在定义时就已经确定，而指针的大小在不同的系统和编译器下是不同的。
- 内存分配方式不同：数组在定义时会自动分配内存，而指针需要手动分配内存（指new关键字）。
- 使用方式不同：数组名可以用作指针，但指针并不总是指向数组。

需要注意的是，数组名在作为参数传递给函数时，会自动转换为指向数组第一个元素的指针，因此函数参数类型为数组和指针时是等价的。

### 14 student* stu = new student[classSize];为什么可以通过stu[0]访问

ChatGPT

因为 stu 是一个指向 student 类型的指针，new student[classSize] 分配的内存空间被当作一个 student 类型的数组，所以可以使用指针

的数组下标形式 stu[0]、stu[1] 等来访问这个数组中的元素。实际上 stu[i] 的含义是 *(stu+i)，即对指针偏移 i 个 student 类型长度的位置进行取值操作。

### 15 const int* 和int*类型不同吗？

是的，`const int*` 和 `int*` 是不同的类型。

`int*` 表示一个指向 `int` 类型变量的指针，可以通过指针来修改所指向的变量的值，如下所示：

```
int x = 10;

int* p = &x;

*p = 20; // 修改 x 的值为 20
```

而 `const int*` 表示一个指向 `const int` 类型变量的指针，指针所指向的变量的值是只读的，不能通过指针来修改它的值，如

下所示：

```
const int y = 10;

const int* q = &y;

// *q = 20; // 错误，不能修改 y 的值
```

因此，这两种指针类型是不同的，它们的用途也不同。`int*` 主要用于表示指向可修改变量的指针，而 `const int*` 则主要用于

表示指向只读变量的指针，或者作为函数参数来表示该参数的值不会被修改。

### 16 decltype((m))是什么意思

decltype((m)) 表示对变量 m 进行求值得到的表达式的类型。需要注意的是，括号是必须的，因为如果没有括号，则 decltype 将

推导变量 m 的类型而不是表达式的类型。如果没有括号，例如 decltype(m)，则 decltype 返回变量 m 的类型，而不是表达式 (m

) 的类型。由于 (m) 是一个表达式，它的类型是 float&，所以 decltype((m)) 返回的类型也是 float&。这意味着，变量 v3 的类型为

float&，它是对变量 m 的引用。在某些情况下，使用 decltype((x)) 可以用于返回表达式的引用类型，从而允许对表达式进行修改。但是需要注意，如果表达式的值是右值（例如字面量或临时对象），则不能将其赋值给引用类型的变量。

### 17 delctype((m+n))是什么？

在表达式 `decltype((m+n))` 中，使用了一对括号将表达式 `(m+n)` 包含在内，这意味着我们不是在获取变量 `m` 和 `n` 的类型，而是在

获取一个对表达式 `(m+n)` 的引用类型。如果 `m` 和 `n` 都是 `float` 类型的变量，那么表达式 `(m+n)` 的结果也是 `float` 类型。然而，由于使用了一对额外的括号将表达式 `(m+n)` 包含在内，所以 `decltype((m+n))` 的结果是一个引用类型，即 `float&`。

需要注意的是，这种使用一对额外的括号的方式可以用于将任何表达式转换为引用类型，例如：

```
int x = 1;

int y = 2;

int& rx = x;

decltype((x+y)) z = x + y;  // decltype((x+y)) 是一个引用类型，z 是对表达式 (x+y) 的引用

decltype((rx)) ry = x;  // decltype((rx)) 是一个引用类型，ry 是对变量 rx 的引用
```

在上面的代码中，`decltype((x+y))` 和 `decltype((rx))` 都是引用类型，因为使用了一对额外的括号将表达式 `(x+y)` 和变量 `rx` 包含

在内。这种技巧在某些情况下非常有用，但是也可能会导致代码难以理解和维护，因此需要谨慎使用。

### 18 为什么const赋给非const是非法的

ChatGPT

在 C++ 中，将 const 类型的值赋给非 const 类型的变量是非法的，这是因为 const 类型的变量或者值是不可修改的。

将 const 类型的值赋给非 const 类型的变量会导致值的可修改性发生变化，这会破坏 const 的语义。const会影响函数的特征标

### 19 char *name=new char[100]怎么删除指针name

ChatGPT

使用delete[] name可以删除动态分配的char数组，释放内存。注意，delete和delete[]是有区别的，delete用于删除动态分配的单个对象，而delete[]用于删除动态分配的数组对象。因此，如果使用delete name来删除动态分配的char数组，会导致未定义的行为，可能会导致内存泄漏或者程序崩溃。所以，正确的删除方式是使用delete[] name。

### 20 strcpy_s()如果目标缓冲区大小和源字符串大小一样可以吗？

缓冲区指的是目标字符串的内存缓冲区

如果目标缓冲区大小和源字符串大小一样，使用strcpy_s函数复制字符串也是可以的。strcpy_s函数的第二个参数是目标缓冲区的大小，第三个参数是源字符串。如果目标缓冲区大小和源字符串大小相等，则可以将目标缓冲区大小设为源字符串大小加1，因为字符串需要以'\0'结尾，也就是strlen()+1，因为strlen()不统计末尾的'\0'。

### 21 头文件申明函数模板，但是cpp文件中不显式实例化模板，main文件调用模板函数出错

ChatGPT

如果在cpp文件中定义模板函数但没有显式实例化模板，而在main文件中使用模板函数，会出现链接错误。这是因为模板函数的实现在cpp文件中，但是编译器需要在链接时生成模板函数的实例化代码，而没有显式实例化模板的话，编译器无法生成相应的代码，导致链接错误。为了解决这个问题，可以将模板函数的实现放在头文件中，或者在cpp文件中显式实例化模板函数。另外，也可以在cpp文件中包含头文件，但需要在头文件中声明模板函数的实现。

### 22 显式具体化和显式实例化的区别

ChatGPT

显式具体化（Explicit specialization）和显式实例化（Explicit instantiation）都是用于模板的特殊化，但是它们的作用和用法是不同的

。

显式具体化是指对特定的模板参数进行重载，也就是我们会为某些特定的模板参数提供不同的实现。显式具体化在定义时需要提供模板参数的具体类型，通常使用 template<> 关键字进行定义，如下所示：

```
template<typename T>

void foo(T t) {

​    std::cout << t << std::endl;

}

template<>  // 显式具体化

void foo<int>(int t) {

​    std::cout << "Explicit specialization for int: " << t << std::endl;

}
```

显式实例化则是为编译器生成代码实例，即在编译时实例化模板函数或类，从而减少编译时间和二进制代码的大小。显式实例化在使用时需要

提供模板参数的具体类型，通常使用 template 关键字和尖括号进行实例化，如下所示：

```
template<typename T>

T max(T a, T b) {

​    return a > b ? a : b;

}

// 显式实例化，会在编译时生成实例化后的代码

template int max<int>(int a, int b);

template double max<double>(double a, double b);
```

显式具体化和显式实例化的区别在于，显式具体化是对特定的模板参数进行重载，而显式实例化是在编译时生成实例化后的代码。显式具体化通常用于为特定类型提供定制化的实现，而显式实例化则用于减少编译时间和二进制代码的大小。

### 23 ertern和static的区别

ChatGPT

extern和static是两个在C/C++中具有相反含义的关键字。

extern用于在一个源文件中引用另一个源文件中定义的变量或函数。当你在一个源文件中使用extern声明一个变量或函数时，你告诉编译器该变量或函数是在另一个源文件中定义的，编译器在编译时不会为它分配存储空间，而是在链接阶段找到其定义的位置。

static用于修饰函数或变量，具体的作用如下：

当用于修饰全局变量时，static表示将该变量的作用域限制在当前源文件中。这意味着，其他源文件无法访问该变量，即使使用了extern关键字也无效。在不同的源文件中，如果使用static修饰同名的全局变量，它们是完全独立的，互相不会干扰。

当用于修饰函数时，static表示将该函数的作用域限制在当前源文件中。这样可以避免函数名与其他源文件中的函数名发生冲突。使用static修饰的函数只能在当前源文件中被调用，无法被其他源文件中的函数调用。

总之，extern和static是两个非常不同的关键字，extern用于在多个源文件中共享变量和函数，而static用于在当前源文件中限制变量和函数的作用域，避免与其他源文件发生冲突。

### 24 假如有两个名称空间A和B有同名的x分别为1和2，在main函数中已经定义了一个x=0，然后相继使用using  A::x;using B::x，现在x=？

如果在使用using声明之前已经定义了一个x变量，那么在使用using A::x的时候会导致编译失败。

### 25 已经定义了一个x=0，然后相继使用using  namespace A;using namespace B，会发生什么?

如果 A 和 B 命名空间都有同名的变量 x，而你在代码中使用了 using namespace A; 和 using namespace B;，那么会隐藏A和B中的名称x

### 26 假如先using namespace A;再using B::x，会发生什么？

这里使用了using B::x语句，指定了使用B命名空间中的x变量，因此输出的结果应该是2。而使用using namespace A语句导入了A命名空间中的所有名称，但由于没有直接使用A中的x变量，因此不会发生名称冲突。

### 27 假如先using B::x，再using namespace A，会发生什么？

在这个程序中，使用了using B::x声明了变量x来自命名空间B，然后又使用了using namespace A，引入了A命名空间中的所有变量。但由于之前已经声明了变量x来自B命名空间，所以最终输出的x的值是2

### 28 为什么using namespace A;using B::x;不会编译失败，而 int x=0;using B::x;会编译失败？

在这个例子中，首先使用 using namespace A; 引入了命名空间 A 中的变量 x，然后使用 using B::x; 引入了命名空间 B 中的变量 x。这时

，x 的定义已经被成功地引入了作用域中，因此不会出现编译错误。

using B::x; 语句只是声明了一个名称为 x 的变量，它并没有定义一个新的变量。编译器会查找已有的具有该名称的变量，并将其引入当前的作用域中，这个过程被称为名称查找。

而 int x = 0; using B::x; 语句中的 int x = 0; 是定义了一个新的变量 x，它与命名空间 B 中的变量 x 重名，因此编译器无法判断应该引用哪个变量，会产生编译错误。

using namespace A语句只是将命名空间A中的所有成员引入到当前作用域中，包括变量x的声明，但并不是在当前作用域中定义变量x。因此，在后续使用using B::x时，编译器可以找到命名空间B中的变量x的定义，与命名空间A中的变量x没有冲突。

而直接使用int x=0; using B::x;则会定义一个全局变量x，而命名空间B中的变量x再次定义相当于定义了一个新的变量，与全局变量x重名，因此会导致编译错误。

### 29 using namespace A;int x=0;会发生什么

ChatGPT

在全局作用域下，使用 using namespace A 引入了命名空间 A 中的所有名称，包括变量 x，此时 x 变量在全局作用域下可见。

接着在全局作用域下定义了一个整型变量 x，这个 x 变量与 A 命名空间中的 x 变量不是同一个变量，它们是两个独立的变量，类型也不同，因此没有任何影响。

因此，在 using namespace A 之后定义全局变量 int x=0 不会发生任何问题。

### 30 在函数中优先级：int x=0 > using A::x > using namespace A;

在函数中，如果定义了一个局部变量 int x = 0，那么这个变量的作用域就是这个函数中，会遮盖掉名称空间 A 中的 x 变量。所以在这个函

数中使用 x 变量时，会优先使用这个局部变量。

如果使用了 using A::x，表示这个函数中的 x 变量将会被名称空间 A 中的 x 变量所取代，所以在这个函数中使用 x 变量时，会使用名称空

间 A 中的 x 变量。如果使用了 using namespace A，则会在这个函数中引入名称空间 A 中的所有成员（包括变量 x），在使用 x 变量时，会先在局部作用域中查找是否有定义，如果没有，则会在名称空间 A 中查找是否有定义。

综上所述，在函数中的优先级：int x=0 > using A::x > using namespace A。

### 31 可以将string& 赋值给string吗

ChatGPT

可以将一个string&赋值给一个string对象，这个过程会发生引用的绑定。例如：

```
string& r = s1;  // 将引用r绑定到字符串s1上

string s2 = r;   // 将字符串s1的值赋给字符串s2，发生了引用的绑定
```

在这个例子中，首先定义了一个字符串s1和一个引用r，将引用r绑定到s1上。然后将s1的值赋给字符串s2，这个过程会发生引用的绑定，即将r和s2绑定到同一个字符串对象上。

### 32 引用是地址吗

引用并不是地址，它只是一个别名，是对某个变量的别称或者称呼。引用与它所绑定的变量是同一对象的不同名称，它可以被用作访问该变量。

通过引用，可以在不使用指针的情况下，直接访问到该变量的值，从而使代码更加清晰简洁。

虽然在实现上，引用有可能会被编译器转换成一个指针，但从概念上讲，引用是不同于指针的，引用更像是一种别名，而指针则是一个变量，存储了另一个变量的内存地址。

因此，引用和指针虽然都可以用来访问变量，但它们的本质不同，需要根据实际需求来选择使用哪种方式。

### 33 参数类型为const string&是不是限制了字符串参数，使其不能被修改？

ChatGPT

是的，const string& 限制了该字符串对象不能被修改。因为这里使用了 const 关键字，表示该引用是一个常量引用，也就是说不能通过该引用来修改字符串对象。只能读取字符串对象的值，但不能修改其值。

这样设计的好处是可以保护原始字符串对象不被意外地修改，同时也可以提高代码的效率，因为不需要创建临时的副本字符串对象。如果函数确实不需要修改原始字符串对象，最好使用 const string& 来传递参数，这有助于代码的可读性和可维护性。

### 34 可不可以将const string& 类型赋给string类型？

```
class Person

{

private:

 string lname;//lastname

public:

 Person(const string& ln, const char* fn = "Heyyou");

}

Person::Person(const string& ln, const char* fn)

{

 lname = ln;

}
```

在这个例子中，将 ln 赋给 lname 实际上是调用了 string 类型的赋值运算符，这个运算符会将 ln 中的值复制到 lname 中。因此，在执行赋值运算符时，实际上是将 ln 中的 const 限定符去掉了，这使得它的值可以被修改。不过，这个修改是发生在类成员变量 lname 中的，而不是在 ln 中的。

### 35 strcpy_s()函数

函数会将源字符串 src 中的内容拷贝到目标字符串 dest 中，直到遇到源字符串中的空字符 '\0' 或者达到目标字符串缓冲区的末尾。如果拷贝过程中目标字符串的缓冲区不足，或者源字符串 src 是空指针，则 strcpy_s() 函数会返回一个非零错误码。

### 36 不同项目相同的命名空间会冲突吗

ChatGPT

在不同项目中定义同名的命名空间不会造成冲突，因为命名空间是局部的，不同项目中的同名命名空间实际上是不同的空间，彼此独立互不干扰。但是如果在同一个项目中定义了两个同名的命名空间，则会造成冲突，需要使用不同的名称或者合并这两个命名空间。