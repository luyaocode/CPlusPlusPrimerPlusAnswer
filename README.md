#### Chapter01 学习笔记

#### Chapter02 开始学习C++

#### Chapter03 处理数据

#### Chapter04 复合类型

#### Chapter05 循环和关系表达式

#### Chapter06 分支语句和逻辑运算符

#### Chapter07 函数——C++的编程模块

#### Chapter08 函数探幽

#### Chapter09 内存模型和名称空间

#### Chapter10 对象和类

#### Chapter11 使用类

#### Chapter12 类和动态内存分配

#### Chapter13 类继承

#### Chapter14 C++中的代码重用

#### Chapter15 友元、异常和其他

#### Chapter16 string类和标准模板库

#### Chapter17 输入、输出和文件

#### Chapter18 探讨C++新标准



### **1 指针、引用和变量名的区别**

指针、引用和变量名都是C++中用于表示数据对象的标识符，但它们有以下区别：

1. 变量名：变量名是标识符的一种形式，用于标识内存中存储的数据对象。通过变量名可以直接访问数据对象。
2. 指针：指针是一种特殊类型的变量，用于存储内存地址。指针变量中存储的地址可以用来访问该地址上的数据对象。指针使用*操作符进行间接

引用。

3. 引用：引用也是一种特殊类型的变量，它相当于给一个已经存在的变量起了一个别名，可以用来修改该变量的值。引用使用&操作符进行声明和

使用。

总的来说，指针和引用都可以用来修改数据对象的值，而变量名只能直接访问数据对象。指针可以指向不同类型的数据对象，而引用只能指向与其

绑定的变量的类型相同的数据对象。

### 2 指针和引用的区别

引用和指针是C++中两种不同的数据类型，它们在使用上有一些区别，如下所述：

1. 指针是一个对象，它存储一个变量的地址，而引用是一个别名，它与变量绑定在一起。引用在内部实现上通常被视为指针，但是它们的使用方式更像变量，因为它们不需要进行解引用操作。

2. 指针可以为空（nullptr），而引用不能。这意味着引用必须在定义时初始化，并始终绑定到一个变量上。
3. 指针可以重新分配和修改，而引用一旦被初始化就不能更改其绑定的变量。这是因为引用实际上是被绑定到变量的别名，而不是一个独立的对象。

4. 指针可以被解除引用来访问其指向的变量，而引用直接访问其绑定的变量。这意味着使用指针时需要进行解引用操作，而使用引用时不需要。
5. 指针可以进行算术运算，比如加法、减法等，以便移动指向的位置，而引用没有这些运算。这也是因为引用实际上是变量的别名，而不是指向变量的指针。

综上所述，指针和引用各有其优缺点，应根据具体情况选择使用哪种类型。在一些情况下，如函数参数传递和返回值，使用引用可以提供更加方便

和清晰的代码；在其他情况下，如需要进行算术运算或者需要动态分配内存等，使用指针是更为合适的。

### 3 函数引用传参、函数调用

```
void func(int& a) {

​    a = 10;

}

int main() {

​    int x = 0;

​    func(x); // 此处传入的是x的引用，即&a

​    cout << x; // 输出10

​    return 0;

}
```

为什么调用时是func(x)而不是func(&x)

如果函数参数是引用类型，可以直接传入变量名作为参数，不需要使用取地址符 &。因为引用类型本身就是一个别名，传入变量名时会自动转换为

对应的引用。

### 4 结构引用传参和结构指针传参的区别

结构引用传参和指针传参都可以用来修改传入的结构体，但两者有以下区别：

1. 使用结构引用传参时，函数参数的类型是结构的引用，也就是`struct MyStruct&`，在函数内部直接对结构的引用进行操作即可，用法和直接对结构进行操作类似，使用起来更加方便和自然。

2. 使用指针传参时，函数参数的类型是结构的指针，也就是`struct MyStruct*`，需要在函数内部使用指针操作符`->`或者`*`来访问结构体成员，用法相对来说比较繁琐，但是可以更加灵活。

总的来说，如果只需要对结构体进行简单的操作，使用结构引用传参会更加方便，如果需要进行更复杂的操作或者涉及到内存管理等问题，使用指针传参可能更加适合。

### 5 1.0f和1.0有什么区别

在 C++ 中，浮点常量默认被解释为双精度浮点数，因此使用 `1.0` 表示双精度浮点数。如果您希望使用单精度浮点数，可以在数字后面添加 `f`，例如 `1.0f`。

在实际应用中，对于单精度浮点数的计算，建议使用 `1.0f` 而不是 `1.0`。这是因为 `1.0` 在计算机内部表示为双精度浮点数，如果使用 `1.0` 进行计算，则需要执行双精度到单精度的转换，这可能会导致精度损失。

### 6 if (NAN==NAN)

ChatGPT

表达式 NAN == NAN 的结果是 false。这是因为NaN 的定义是不是一个数字，它不等于任何数字，包括它自己。这种特殊的比较方式是 IEEE 754标准中 NaN 的定义所决定的。如果需要检查一个值是否为 NaN，可以使用 isnan() 函数，该函数将返回一个非零值（即 true），如果参数是NaN，则返回 true，否则返回 0（即 false）。

### 7 long double和double都是8个字节的情况下，他们是一样的吗

ChatGPT

虽然long double和double都是浮点型数据类型，但是它们的存储方式和精度上有所不同。在大多数平台上，double通常占用8个字节，而long double通常占用12或16个字节，具体取决于编译器和平台的实现。这意味着long double能够表示更大范围的数值，并且通常比double的精度更高。此外，long double在进行浮点运算时所能保留的有效数字位数也更多，因此在需要更高精度计算时，long double通常是更好的选择。

### 8 使用double可以计算最大的阶乘

ChatGPT

使用double类型变量能计算的最大阶乘是170。因为double类型的精度有限，当超过一定值后会出现误差。对于更大的数值计算，可以使用高精度计算库，例如GMP（GNU Multiple Precision Arithmetic Library）。

### 9 delete和delete[]

如果 `end` 是指向数组最后一个元素之后位置的指针，而不是使用 `new` 操作符动态分配的指针，那么在释放内存空间时，我们不应该使用 `delete` 或者 `delete[]` 操作符释放 `end` 指向的内存空间，否则会导致程序崩溃或者其他不可预期的行为。在这种情况下，我们只需要使用`delete[] arr` 操作符释放整个数组所占用的内存空间即可。因此，最终代码可能如下所示：delete[] arr;需要注意的是，在使用 `delete` 或者 `delete[]` 操作符释放内存空间时，我们不需要将指针设置为 `nullptr`。这是因为，在释放内存空间后，指针不再指向有效的内存地址，将其设置为 `nullptr` 可以避免出现悬空指针的问题，但并不是必需的。

### 10 struct exp_st;是结构体的申明还是定义

struct exp_st; 是结构体不完整申明，方便在源文件中修改结构具体内容。main.cpp要使用源文件func.cpp申明的完整结构体，需要包含该源文件#include "func.cpp",否则会编译报错，不建议在一个cpp文件包含另一个cpp文件，可能导致重复定义。所以尽量在头文件给出结构体完整申明

在 C++ 中，声明和定义是的两个不同的概念。声明是指在代码中告诉编译器一个实体的类型和名称，而不进行实际的分配内存或初始化。例如，以下语句就是一个变量的声明：

int x；

这条语句告诉编译器，有一个名为 x 的 int 类型变量，但它并没有分配实际的内存空间。定义则是指在代码中给出一个实体的具体实现，包括分配内存、初始化等操作。例如，以下语句就是一个变量的定义：

int x = 42;

### 11 student* stu = new student[classSize];是什么意思

ChatGPT

这段代码使用了 new 运算符来在堆上动态地分配了一个长度为 classSize 的数组，并将数组的首地址赋值给了指针 stu。该数组中的元素类

型是 student 结构体，因此stu 指向的是一个 student 类型的数组。由于数组是动态分配的，因此数组的长度是在运行时确定的，而不是

在编译时确定的。

请参考//double* arr = new double[MaxSize];指的是将堆上new出来的数组的首地址赋值给指针arr

### 12 student *stu[10]=new student[5]是什么意思（误）

ChatGPT

这个语句会在编译时报错，因为它是错误的语法。数组名和 new 表达式之间不能使用 [] 运算符。如果你想要创建一个包含10个指向

student 结构体对象的指针的数组，你可以这样写：

```
student* stu[10];

for (int i = 0; i < 10; i++) {

	stu[i] = new student[5];

}
```

这个语句将创建一个包含10个指向 student 结构体对象的指针的数组。然后，对于每个指针，它会分配一个包含5个 student 结构体对象的数组。注意，这里的指针数组不需要使用 new 进行分配，因为它是在栈上分配的。只有每个指针指向的数组需要使用 new 进行分配，因为它们是在堆上分配的。

### 13 数组名和指针的区别

ChatGPT

数组名和指针有以下区别：

- 类型不同：数组名是数组类型，指针是指针类型。
- 大小不同：数组的大小在定义时就已经确定，而指针的大小在不同的系统和编译器下是不同的。
- 内存分配方式不同：数组在定义时会自动分配内存，而指针需要手动分配内存（指new关键字）。
- 使用方式不同：数组名可以用作指针，但指针并不总是指向数组。

需要注意的是，数组名在作为参数传递给函数时，会自动转换为指向数组第一个元素的指针，因此函数参数类型为数组和指针时是等价的。

### 14 student* stu = new student[classSize];为什么可以通过stu[0]访问

ChatGPT

因为 stu 是一个指向 student 类型的指针，new student[classSize] 分配的内存空间被当作一个 student 类型的数组，所以可以使用指针

的数组下标形式 stu[0]、stu[1] 等来访问这个数组中的元素。实际上 stu[i] 的含义是 *(stu+i)，即对指针偏移 i 个 student 类型长度的位置进行取值操作。

### 15 const int* 和int*类型不同吗？

是的，`const int*` 和 `int*` 是不同的类型。

`int*` 表示一个指向 `int` 类型变量的指针，可以通过指针来修改所指向的变量的值，如下所示：

```
int x = 10;

int* p = &x;

*p = 20; // 修改 x 的值为 20
```

而 `const int*` 表示一个指向 `const int` 类型变量的指针，指针所指向的变量的值是只读的，不能通过指针来修改它的值，如

下所示：

```
const int y = 10;

const int* q = &y;

// *q = 20; // 错误，不能修改 y 的值
```

因此，这两种指针类型是不同的，它们的用途也不同。`int*` 主要用于表示指向可修改变量的指针，而 `const int*` 则主要用于

表示指向只读变量的指针，或者作为函数参数来表示该参数的值不会被修改。

### 16 decltype((m))是什么意思

decltype((m)) 表示对变量 m 进行求值得到的表达式的类型。需要注意的是，括号是必须的，因为如果没有括号，则 decltype 将

推导变量 m 的类型而不是表达式的类型。如果没有括号，例如 decltype(m)，则 decltype 返回变量 m 的类型，而不是表达式 (m

) 的类型。由于 (m) 是一个表达式，它的类型是 float&，所以 decltype((m)) 返回的类型也是 float&。这意味着，变量 v3 的类型为

float&，它是对变量 m 的引用。在某些情况下，使用 decltype((x)) 可以用于返回表达式的引用类型，从而允许对表达式进行修改。但是需要注意，如果表达式的值是右值（例如字面量或临时对象），则不能将其赋值给引用类型的变量。

### 17 delctype((m+n))是什么？

在表达式 `decltype((m+n))` 中，使用了一对括号将表达式 `(m+n)` 包含在内，这意味着我们不是在获取变量 `m` 和 `n` 的类型，而是在

获取一个对表达式 `(m+n)` 的引用类型。如果 `m` 和 `n` 都是 `float` 类型的变量，那么表达式 `(m+n)` 的结果也是 `float` 类型。然而，由于使用了一对额外的括号将表达式 `(m+n)` 包含在内，所以 `decltype((m+n))` 的结果是一个引用类型，即 `float&`。

需要注意的是，这种使用一对额外的括号的方式可以用于将任何表达式转换为引用类型，例如：

```
int x = 1;

int y = 2;

int& rx = x;

decltype((x+y)) z = x + y;  // decltype((x+y)) 是一个引用类型，z 是对表达式 (x+y) 的引用

decltype((rx)) ry = x;  // decltype((rx)) 是一个引用类型，ry 是对变量 rx 的引用
```

在上面的代码中，`decltype((x+y))` 和 `decltype((rx))` 都是引用类型，因为使用了一对额外的括号将表达式 `(x+y)` 和变量 `rx` 包含

在内。这种技巧在某些情况下非常有用，但是也可能会导致代码难以理解和维护，因此需要谨慎使用。

### 18 为什么const赋给非const是非法的

ChatGPT

在 C++ 中，将 const 类型的值赋给非 const 类型的变量是非法的，这是因为 const 类型的变量或者值是不可修改的。

将 const 类型的值赋给非 const 类型的变量会导致值的可修改性发生变化，这会破坏 const 的语义。const会影响函数的特征标

### 19 char *name=new char[100]怎么删除指针name

ChatGPT

使用delete[] name可以删除动态分配的char数组，释放内存。注意，delete和delete[]是有区别的，delete用于删除动态分配的单个对象，而delete[]用于删除动态分配的数组对象。因此，如果使用delete name来删除动态分配的char数组，会导致未定义的行为，可能会导致内存泄漏或者程序崩溃。所以，正确的删除方式是使用delete[] name。

### 20 strcpy_s()如果目标缓冲区大小和源字符串大小一样可以吗？

缓冲区指的是目标字符串的内存缓冲区

如果目标缓冲区大小和源字符串大小一样，使用strcpy_s函数复制字符串也是可以的。strcpy_s函数的第二个参数是目标缓冲区的大小，第三个参数是源字符串。如果目标缓冲区大小和源字符串大小相等，则可以将目标缓冲区大小设为源字符串大小加1，因为字符串需要以'\0'结尾，也就是strlen()+1，因为strlen()不统计末尾的'\0'。

### 21 头文件申明函数模板，但是cpp文件中不显式实例化模板，main文件调用模板函数出错

ChatGPT

如果在cpp文件中定义模板函数但没有显式实例化模板，而在main文件中使用模板函数，会出现链接错误。这是因为模板函数的实现在cpp文件中，但是编译器需要在链接时生成模板函数的实例化代码，而没有显式实例化模板的话，编译器无法生成相应的代码，导致链接错误。为了解决这个问题，可以将模板函数的实现放在头文件中，或者在cpp文件中显式实例化模板函数。另外，也可以在cpp文件中包含头文件，但需要在头文件中声明模板函数的实现。

### 22 显式具体化和显式实例化的区别

ChatGPT

显式具体化（Explicit specialization）和显式实例化（Explicit instantiation）都是用于模板的特殊化，但是它们的作用和用法是不同的

。

显式具体化是指对特定的模板参数进行重载，也就是我们会为某些特定的模板参数提供不同的实现。显式具体化在定义时需要提供模板参数的具体类型，通常使用 template<> 关键字进行定义，如下所示：

```
template<typename T>

void foo(T t) {

​    std::cout << t << std::endl;

}

template<>  // 显式具体化

void foo<int>(int t) {

​    std::cout << "Explicit specialization for int: " << t << std::endl;

}
```

显式实例化则是为编译器生成代码实例，即在编译时实例化模板函数或类，从而减少编译时间和二进制代码的大小。显式实例化在使用时需要

提供模板参数的具体类型，通常使用 template 关键字和尖括号进行实例化，如下所示：

```
template<typename T>

T max(T a, T b) {

​    return a > b ? a : b;

}

// 显式实例化，会在编译时生成实例化后的代码

template int max<int>(int a, int b);

template double max<double>(double a, double b);
```

显式具体化和显式实例化的区别在于，显式具体化是对特定的模板参数进行重载，而显式实例化是在编译时生成实例化后的代码。显式具体化通常用于为特定类型提供定制化的实现，而显式实例化则用于减少编译时间和二进制代码的大小。

### 23 ertern和static的区别

ChatGPT

extern和static是两个在C/C++中具有相反含义的关键字。

extern用于在一个源文件中引用另一个源文件中定义的变量或函数。当你在一个源文件中使用extern声明一个变量或函数时，你告诉编译器该变量或函数是在另一个源文件中定义的，编译器在编译时不会为它分配存储空间，而是在链接阶段找到其定义的位置。

static用于修饰函数或变量，具体的作用如下：

当用于修饰全局变量时，static表示将该变量的作用域限制在当前源文件中。这意味着，其他源文件无法访问该变量，即使使用了extern关键字也无效。在不同的源文件中，如果使用static修饰同名的全局变量，它们是完全独立的，互相不会干扰。

当用于修饰函数时，static表示将该函数的作用域限制在当前源文件中。这样可以避免函数名与其他源文件中的函数名发生冲突。使用static修饰的函数只能在当前源文件中被调用，无法被其他源文件中的函数调用。

总之，extern和static是两个非常不同的关键字，extern用于在多个源文件中共享变量和函数，而static用于在当前源文件中限制变量和函数的作用域，避免与其他源文件发生冲突。

### 24 假如有两个名称空间A和B有同名的x分别为1和2，在main函数中已经定义了一个x=0，然后相继使用using  A::x;using B::x，现在x=？

如果在使用using声明之前已经定义了一个x变量，那么在使用using A::x的时候会导致编译失败。

### 25 已经定义了一个x=0，然后相继使用using  namespace A;using namespace B，会发生什么?

如果 A 和 B 命名空间都有同名的变量 x，而你在代码中使用了 using namespace A; 和 using namespace B;，那么会隐藏A和B中的名称x

### 26 假如先using namespace A;再using B::x，会发生什么？

这里使用了using B::x语句，指定了使用B命名空间中的x变量，因此输出的结果应该是2。而使用using namespace A语句导入了A命名空间中的所有名称，但由于没有直接使用A中的x变量，因此不会发生名称冲突。

### 27 假如先using B::x，再using namespace A，会发生什么？

在这个程序中，使用了using B::x声明了变量x来自命名空间B，然后又使用了using namespace A，引入了A命名空间中的所有变量。但由于之前已经声明了变量x来自B命名空间，所以最终输出的x的值是2

### 28 为什么using namespace A;using B::x;不会编译失败，而 int x=0;using B::x;会编译失败？

在这个例子中，首先使用 using namespace A; 引入了命名空间 A 中的变量 x，然后使用 using B::x; 引入了命名空间 B 中的变量 x。这时

，x 的定义已经被成功地引入了作用域中，因此不会出现编译错误。

using B::x; 语句只是声明了一个名称为 x 的变量，它并没有定义一个新的变量。编译器会查找已有的具有该名称的变量，并将其引入当前的作用域中，这个过程被称为名称查找。

而 int x = 0; using B::x; 语句中的 int x = 0; 是定义了一个新的变量 x，它与命名空间 B 中的变量 x 重名，因此编译器无法判断应该引用哪个变量，会产生编译错误。

using namespace A语句只是将命名空间A中的所有成员引入到当前作用域中，包括变量x的声明，但并不是在当前作用域中定义变量x。因此，在后续使用using B::x时，编译器可以找到命名空间B中的变量x的定义，与命名空间A中的变量x没有冲突。

而直接使用int x=0; using B::x;则会定义一个全局变量x，而命名空间B中的变量x再次定义相当于定义了一个新的变量，与全局变量x重名，因此会导致编译错误。

### 29 using namespace A;int x=0;会发生什么

ChatGPT

在全局作用域下，使用 using namespace A 引入了命名空间 A 中的所有名称，包括变量 x，此时 x 变量在全局作用域下可见。

接着在全局作用域下定义了一个整型变量 x，这个 x 变量与 A 命名空间中的 x 变量不是同一个变量，它们是两个独立的变量，类型也不同，因此没有任何影响。

因此，在 using namespace A 之后定义全局变量 int x=0 不会发生任何问题。

### 30 在函数中优先级：int x=0 > using A::x > using namespace A;

在函数中，如果定义了一个局部变量 int x = 0，那么这个变量的作用域就是这个函数中，会遮盖掉名称空间 A 中的 x 变量。所以在这个函

数中使用 x 变量时，会优先使用这个局部变量。

如果使用了 using A::x，表示这个函数中的 x 变量将会被名称空间 A 中的 x 变量所取代，所以在这个函数中使用 x 变量时，会使用名称空

间 A 中的 x 变量。如果使用了 using namespace A，则会在这个函数中引入名称空间 A 中的所有成员（包括变量 x），在使用 x 变量时，会先在局部作用域中查找是否有定义，如果没有，则会在名称空间 A 中查找是否有定义。

综上所述，在函数中的优先级：int x=0 > using A::x > using namespace A。

### 31 可以将string& 赋值给string吗

ChatGPT

可以将一个string&赋值给一个string对象，这个过程会发生引用的绑定。例如：

```
string& r = s1;  // 将引用r绑定到字符串s1上

string s2 = r;   // 将字符串s1的值赋给字符串s2，发生了引用的绑定
```

在这个例子中，首先定义了一个字符串s1和一个引用r，将引用r绑定到s1上。然后将s1的值赋给字符串s2，这个过程会发生引用的绑定，即将r和s2绑定到同一个字符串对象上。

### 32 引用是地址吗

引用并不是地址，它只是一个别名，是对某个变量的别称或者称呼。引用与它所绑定的变量是同一对象的不同名称，它可以被用作访问该变量。

通过引用，可以在不使用指针的情况下，直接访问到该变量的值，从而使代码更加清晰简洁。

虽然在实现上，引用有可能会被编译器转换成一个指针，但从概念上讲，引用是不同于指针的，引用更像是一种别名，而指针则是一个变量，存储了另一个变量的内存地址。

因此，引用和指针虽然都可以用来访问变量，但它们的本质不同，需要根据实际需求来选择使用哪种方式。

### 33 参数类型为const string&是不是限制了字符串参数，使其不能被修改？

ChatGPT

是的，const string& 限制了该字符串对象不能被修改。因为这里使用了 const 关键字，表示该引用是一个常量引用，也就是说不能通过该引用来修改字符串对象。只能读取字符串对象的值，但不能修改其值。

这样设计的好处是可以保护原始字符串对象不被意外地修改，同时也可以提高代码的效率，因为不需要创建临时的副本字符串对象。如果函数确实不需要修改原始字符串对象，最好使用 const string& 来传递参数，这有助于代码的可读性和可维护性。

### 34 可不可以将const string& 类型赋给string类型？

```
class Person

{

private:

 string lname;//lastname

public:

 Person(const string& ln, const char* fn = "Heyyou");

}

Person::Person(const string& ln, const char* fn)

{

 lname = ln;

}
```

在这个例子中，将 ln 赋给 lname 实际上是调用了 string 类型的赋值运算符，这个运算符会将 ln 中的值复制到 lname 中。因此，在执行赋值运算符时，实际上是将 ln 中的 const 限定符去掉了，这使得它的值可以被修改。不过，这个修改是发生在类成员变量 lname 中的，而不是在 ln 中的。

### 35 strcpy_s()函数

函数会将源字符串 src 中的内容拷贝到目标字符串 dest 中，直到遇到源字符串中的空字符 '\0' 或者达到目标字符串缓冲区的末尾。如果拷贝过程中目标字符串的缓冲区不足，或者源字符串 src 是空指针，则 strcpy_s() 函数会返回一个非零错误码。

### 36 不同项目相同的命名空间会冲突吗

ChatGPT

在不同项目中定义同名的命名空间不会造成冲突，因为命名空间是局部的，不同项目中的同名命名空间实际上是不同的空间，彼此独立互不干扰。但是如果在同一个项目中定义了两个同名的命名空间，则会造成冲突，需要使用不同的名称或者合并这两个命名空间。

### 37 cin.fail()执行之后不会自动清除错误标记吗,返回true之后错误的输入没有被清理吗？

ChatGPT

在执行cin.fail()时，如果读取失败，会在输入流中设置一个错误标记（failbit），表示读取的数据与期望的数据类型不符。如果后续程序需要

从输入流中读取数据，而没有清除这个错误标记，就会一直触发读取失败。因此，在执行cin.fail()之后，应该使用cin.clear()来清除错误标记

。同时，为了确保后续读取操作能够成功，还需要使用cin.ignore()来忽略输入流中的残留字符。

### 38 cin.fail()返回true之后错误的输入没有被清理吗

是的，当 cin.fail() 返回 true 时，输入流中的错误标志被设置，但是输入流中的数据并没有被清理。如果不清理输入流中的数据，程序会陷

入死循环，因为 cin.fail() 会一直返回 true。因此，需要调用 cin.clear() 来清除输入流的错误标志，并且使用 cin.ignore() 或者

getline() 来清除输入流中的数据。

### 39 实现数字+对象和对象＋数字必须要用到两个友元函数吗

ChatGPT

不一定需要用到两个友元函数，可以使用一个友元函数和一个成员函数来重载数字+对象和对象+数字。

对于数字+对象，可以定义一个非成员函数，将数字作为第一个参数传入，将对象作为第二个参数传入。

对于对象+数字，可以定义一个成员函数，将数字作为参数传入，然后在函数内部实现对象+数字的操作。

### 40 如果必须使用友元函数，是不是需要两个？

ChatGPT

如果要实现数字+对象和对象+数字的重载，确实需要定义两个友元函数，因为两者的参数顺序不同，因此需要定义不同的函数来处理。在定义友

元函数时，需要将类声明为友元，并将友元函数声明为类的友元函数。

### 41 一个描述时间的类包含两种表达方式，分别是小时：分钟和分钟，类还包含一个描述表达方式的属性flag，初始化某种类型的时候，需要给另一种类型初始化吗

ChatGPT

如果这个类中有两种表达方式，其中一种是小时：分钟，另一种是分钟，则需要在初始化某一种表达方式时，将另一种表达方式也进行初始化。

例如，如果要初始化小时：分钟的表达方式，那么应该提供小时和分钟的值，并计算出对应的分钟数，然后将这个值赋值给类中的“分钟”属性

。反之，如果要初始化分钟的表达方式，那么应该提供分钟数，并计算出对应的小时和分钟的值，然后将这两个值分别赋值给类中的“小时”和

“分钟”属性。

无论是哪种表达方式，都应该设置类中的“flag”属性，以指示当前使用的是哪种表达方式。这样，在需要输出时间的值时，就可以根据“flag

”属性来确定使用哪种表达方式。

### 42 Complex a(3.0,4.0)和Complex a{3.0,4.0}是一样的吗

ChatGPT

Complex a(3.0, 4.0)和Complex a{3.0, 4.0}在大多数情况下是等价的。

它们都是使用构造函数创建一个名为a的Complex对象，该对象具有实部3.0和虚部4.0。两者的区别在于初始化方式的不同。

Complex a(3.0, 4.0)使用了传统的函数调用语法来初始化对象，而Complex a{3.0, 4.0}使用了C++11新引入的统一初始化语法。这种语法强制

要求使用花括号，可以更好地避免一些初始化的问题，例如由于隐式转换导致的错误或二义性等。

总体来说，这两种初始化方式大多数情况下是等价的，可以根据个人喜好和代码风格选择使用哪种方式。

### 43 复制构造函数和重载赋值运算符的区别

ChatGPT

在C++中，拷贝构造函数和赋值构造函数都是用来实现对象之间的拷贝或赋值操作的函数。它们有以下区别：

复制构造函数

复制构造函数是一种特殊的构造函数，它的参数是一个同类的对象引用，它的作用是用一个已经存在的对象初始化一个新对象。复制构造函数一

般用于对象初始化时，例如：

c++

Copy code

class MyClass {

public:

​    MyClass(); // 默认构造函数

​    MyClass(const MyClass& other); // 复制构造函数

​    ...

};

MyClass obj1;

MyClass obj2 = obj1; // 调用复制构造函数

在上面的例子中，通过MyClass obj2 = obj1来初始化obj2对象时，会自动调用MyClass的复制构造函数。

重载赋值运算符

是一种用来实现对象之间赋值操作的函数。它与复制构造函数的区别在于，它的参数是一个同类的常引用，返回值是*this，它的作用是将一个

已经存在的对象赋值给当前对象。例如：

c++

Copy code

class MyClass {

public:

​    MyClass(); // 默认构造函数

​    MyClass& operator=(const MyClass& other); // 重载赋值运算符

​    ...

};

MyClass obj1, obj2;

obj2 = obj1; // 调用重载赋值运算符

在上面的例子中，通过obj2 = obj1来将obj1对象赋值给obj2对象时，会自动调用MyClass的赋值构造函数。

需要注意的是，复制构造函数和重载赋值运算符函数的实现方式是不同的，它们也有各自的适用场景。一般来说，当需要初始化一个新对象时，

应该使用复制构造函数，当需要将一个已有的对象赋值给另一个对象时，应该使用重载赋值运算符。另外，需要注意在实现自定义的复制构造函

数和重载赋值运算符时，要考虑动态内存的分配和释放问题，避免出现内存泄漏等问题。

### 44 指针成员变量给类带来的问题

1 对象过期，但是指针成员指向的数据仍保留在内存中，需要在析构函数中手动释放该指针

2 当析构函数释放该指针后，如果程序将该对象初始化为另一个对象，则析构函数将释放指针这两次，引起错误。解决办法是定义复制构造函数

重新申请一块内存，使得指针指向数据是一样的，但是指针不是同一个指针

3 将一个对象赋值给另一个对象，也会导致两个对象的指针相同，解决办法重载赋值运算符，重新申请一块内存。

### 45 复制构造函数和重载赋值符号都会生成新的对象吗

ChatGPT

是的，复制构造函数和重载赋值运算符都会生成新的对象。

复制构造函数在创建一个新对象时，使用一个已经存在的对象来初始化它。复制构造函数会在已有的对象的基础上，创建一个新的对象，新对象

与原有对象的内容完全相同，但它们是两个不同的对象，它们的内存空间是独立的。

重载赋值运算符将一个已经存在的对象的值赋给另一个对象。在这个过程中，新的对象会被创建出来，然后将被赋值对象的值复制到新对象中，

这样，两个对象的内容就相同了。和复制构造函数一样，重载赋值运算符也会在已有的对象的基础上，创建一个新的对象，新对象和原有对象的

内存空间是独立的。

### 46 const修饰的对象不能调用成员函数吗？

ChatGPT

可以调用成员函数，但是需要注意的是，如果该成员函数没有被声明为const成员函数，则不能被const对象调用。因为const对象是不能修改的

，而非const成员函数可能会修改对象的状态，因此编译器会报错。

如果一个成员函数不会修改对象的状态，那么它应该被声明为const成员函数。在成员函数的声明和定义中，将关键字const加在函数参数列表后

面即可，如下所示：

cpp

Copy code

void func() const;

这样，const对象也能调用这个成员函数了。在const成员函数中，不能修改成员变量的值，也不能调用非const成员函数。这是因为在const成员

函数中，成员变量的值是不允许被修改的，而非const成员函数可能会修改成员变量的值。

### 47 String a("Green)和String a=String("Green")等价吗

ChatGPT

在这种情况下，这两个语句是等价的。它们都创建了一个名为 a 的 String 对象，并将其初始化为 "Green"。第一种语法使用了构造函数初始

化，而第二种语法使用了赋值运算符。

### 48 复制构造函数和重载赋值运算符应该设置为private还是public

ChatGPT

复制构造函数和重载赋值运算符的访问控制符应该设置为 public 或 private，具体取决于类的设计需求。一般来说，如果类的设计需要支持复

制构造和赋值操作，则应该将这两个函数声明为 public，否则应该将其声明为 private。

如果将复制构造函数和重载赋值运算符声明为 public，则可以使用类对象进行复制或赋值操作。这通常是一个有用的特性，例如，当需要创建

类的副本或将类的实例传递给函数时，就需要使用复制构造函数或赋值操作符进行对象的复制或赋值。

如果将复制构造函数和重载赋值运算符声明为 private，则不能从类外部直接调用这两个函数，因此类对象不能进行复制或赋值操作。这种情况

通常出现在一些设计模式中，例如单例模式，因为单例模式要求只能有一个类实例存在，所以复制构造函数和赋值操作符通常被声明为 private

，以防止多个实例被创建。

需要注意的是，将复制构造函数和重载赋值运算符声明为 private 可能会影响类的子类，因为子类无法访问父类的私有成员函数。如果希望子

类能够继承复制构造函数和重载赋值运算符，则需要将它们声明为 protected。

### 49 Queue::Queue(int qs) :qsize(qs){}为什么可以这样给const qs赋值？

ChatGPT

在 C++ 中，const 变量可以在构造函数初始化列表中进行初始化。这是因为在构造函数体中，const 变量的值无法被修改，因此只能在构造函

数初始化列表中对其进行初始化。

在给定的代码中，qsize 是一个 const 变量，它被定义为类的数据成员之一，表示队列的最大容量。在构造函数初始化列表中，使用 qsize(qs

) 来初始化 qsize，其中 qs 是传递给构造函数的参数。这种方式将 qs 的值复制到 qsize 中，以初始化 qsize。

需要注意的是，const 变量一旦被初始化，其值就不能被修改。因此，在构造函数体中，无法直接修改 qsize 的值。如果尝试修改 qsize 的值

，则会导致编译错误。

总之，使用构造函数初始化列表来初始化 const 变量是一种安全和有效的方法，它可以保证 const 变量的值在对象生命周期内保持不变，并提

高代码的可读性和可维护性。

### 50 可以将派生对象赋值给基类引用吗？

这种情况下，通过基类引用调用基类和派生类中的同名「虚函数」时: 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；若该引

用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。这种机制也叫做“多态”，说白点就是调用哪个虚函数，取决于引用的对象

是哪种类型的对象。

### 51 同名非虚函数和同名虚函数在对象直接调用和指针调用、引用调用的情况分别是什么？

对于同名非虚函数，无论是通过对象直接调用、指针调用还是引用调用，都将调用该类型的函数。例如，如果有一个基类指针指向派生类对象，

那么通过该指针调用同名非虚函数将调用基类中的函数。

对于同名虚函数，如果通过对象直接调用，将调用该类型的函数。但是，如果通过指针或引用调用，则将调用指针或引用所指向/引用的对象类

型的函数。例如，如果有一个基类指针指向派生类对象，那么通过该指针调用同名虚函数将调用派生类中的函数。这种情况下，多态会发生。

### 52 静态绑定和动态绑定是什么？

静态绑定（也称为早期绑定）是指在编译时确定函数调用的过程。编译器根据调用函数的类型确定要调用的函数。静态绑定通常用于非虚函数调

用。

动态绑定（也称为晚期绑定）是指在运行时确定函数调用的过程。编译器根据调用函数的实际类型确定要调用的函数。动态绑定通常用于虚函数

调用，它是实现多态的关键。

### 53 虚函数一定会发生动态绑定吗？（将派生类对象赋值给基类对象发生了什么？）

class Base

{

public:

 virtual void print() const { std::cout << "Base: " << this << "\n"; };

};

class Derived :public Base

{

public:

 virtual void print() const { std::cout << "Derived: " << this << "\n"; };

}; 

Derived d; 

Base c = d;

c.print();

这个例子中虚函数没有发生动态绑定，执行的是基类的print()方法。

这是因为在将Derived类对象d赋值给Base类对象c时，发生了对象切割（object slicing）。这意味着只有Base类的成员被复制到c对象中，

Derived类的成员被切割掉了。因此，c对象实际上只是一个Base类的对象，而不是Derived。

当我们调用c的print函数时，由于c的类型是Base，所以编译器将在编译时静态地解析该函数的调用，调用的是Base类的print函数，而不是

Derived类的print函数。因此，在这个例子中，虚函数print没有发生动态绑定。

### 54 为什么不能将基类对象赋值给派生类对象，基类对象指针赋值给派生类对象指针，基类引用赋值给派生类对象引用?

不能将基类对象赋值给派生类对象，基类对象指针赋值给派生类对象指针，基类引用赋值给派生类对象引用的原因是对象的大小问题。

派生类对象的大小通常大于或等于基类对象的大小，因为派生类可以拥有基类的成员变量，以及自己独有的成员变量。如果将一个基类对象赋

值给一个派生类对象，那么派生类对象就无法容纳基类对象中没有的成员变量。因此，这种转换是不允许的。

类似地，由于派生类对象指针和引用指向的对象的大小也可能大于或等于基类对象的大小，因此不能将基类对象指针赋值给派生类对象指针，

基类引用赋值给派生类对象引用。这是因为这些操作可能导致程序访问超出对象的实际大小范围的内存，从而引起不可预测的行为。

（假如派生类对象地址是0000--00FF,基类对象地址是1000--1000F，将基类对象指针1000赋给派生类对象指针，那么原先的ptr+00FF=00FF，不

会越界，而现在的ptr+00FF=1000+00FF=10FF将产生越界）

需要注意的是，可以将指向基类对象的指针或引用转换为指向派生类对象的指针或引用，只要这些基类对象实际上指向的是派生类对象，这种

转换称为向上转型（upcasting）。但是，向上转型不会改变对象的大小，因此它是安全的。

### 55 Cd(const char* per="none", const char* lab="none", int sel = 0, double play = 0.0);这样是不是不需要再写一个空的构造器？

ChatGPT

是的，如果你的构造函数提供了所有成员变量的默认值，那么就不需要再写一个空的默认构造函数了。在这个例子中，Cd 类的构造函数 Cd

(const char* per="none", const char* lab="none", int sel=0, double play=0.0) 给所有成员变量都提供了默认值，所以可以用它来初始

化对象，而不需要再写一个空的默认构造函数。

### 56 派生类的复制构造函数怎么写？

由于派生类的复制构造函数必须调用基类的复制构造函数，因此在定义派生类复制构造函数时，必须使用成员初始化列表来初始化基类的部分

。再在派生类复制构造函数中写新增部分。

Classic::Classic(const Classic& c) :Cd(c)

{

 strcpy_s(mainRecords, strlen(c.mainRecords) + 1, c.mainRecords);

}

将const Classic& c作为参数赋给const Cd& c是合理的

### 57 派生类的重载赋值运算符怎么写？

由于派生类的重载赋值运算符必须调用基类的重载赋值运算符，因此在定义派生类重载赋值运算符时，必须在函数体中调用基类的重载赋值运

算符。

### 58 如果派生类析构函数和基类析构函数都不是虚的，那么销毁派生类对象，析构函数执行次序

ChatGPT

如果派生类析构函数和基类析构函数都不是虚的，在销毁派生类对象时，首先调用派生类的析构函数，然后再调用基类的析构函数，即执行顺

序与构造函数的执行顺序相反。这种情况下，可能会导致对象的部分成员没有被正确释放，从而引发内存泄漏等问题，因此建议在继承层次结

构中，将基类的析构函数设置为虚函数，以确保正确的析构顺序。

### 59 为什么基类析构函数必须设置为虚函数？

在面向对象程序设计中，如果一个基类定义了一个虚析构函数，它的派生类在析构时会自动调用它的虚析构函数。如果基类析构函数不是虚函

数，则当一个派生类对象通过一个基类指针被删除时，只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类对象中的资源无

法被正确释放，产生内存泄漏的风险。

举个例子，假设有一个基类Animal和一个派生类Cat，Cat重写了Animal的析构函数：

class Animal {

public:

​    Animal() { }

​    virtual ~Animal() { }

};

class Cat : public Animal {

public:

​    Cat() { }

​    ~Cat() { cout << "Cat destroyed" << endl; }

};

如果不将Animal的析构函数设置为虚函数，当使用Animal指针删除Cat对象时，只会调用Animal的析构函数，而不会调用Cat的析构函数，导致

Cat对象中的资源没有被正确释放：

Animal* p = new Cat();

delete p; // 只会调用Animal的析构函数，Cat的析构函数没有被调用

因此，在定义基类时，如果有可能存在派生类，基类的析构函数必须设置为虚函数，以保证在删除派生类对象时能够正确调用派生类的析构函

数。

### 60 重载赋值运算符需要设置为虚函数吗？

对于赋值操作符，虽然可以在基类中将成员函数operator=定义成虚函数，但这样做并不会影响派生类中赋值操作符的使用。因为每个类有自己的

赋值操作符。每个类的赋值操作符都有一个和类本身类型相同的形参，该类型必须不同于继承层次中任意其他类的赋值操作符的形参类型。因此

子类的赋值操作符和基类的赋值操作符并不是同一个。但是，在这个子类中仍然有基类的那个操作符，但不是赋值操作符。

将赋值操作符设为虚函数容易让人混淆，因为虚函数必须在基类和派生类中具有相同的形参，基类赋值操作符有一个形参是自身类类型的引用，

如果该操作符为虚函数，则每个类都将得到一个虚函数成员，该成员定义了参数为一个基类对象的operator=。但是，对于派生类而言，这个操作

符与赋值操作符是不同的。

因此，将赋值操作符设为虚函数很容易令人混淆，并且没有什么用处。

### 61 怎么在派生类调用基类的虚函数？

在派生类中，可以通过作用域解析运算符`::`来调用基类的虚函数。例如，如果你想在派生类中调用基类的虚函数`funcA()`，可以使用`Base::

funcA()`¹。这样，即使派生类重写了基类的虚函数，也可以通过这种方式调用基类的虚函数。

### 62 友元函数可以是虚函数吗？

友元函数不属于类，虚函数必须是类的成员，所以友元函数不能是虚函数。

### 63 重载赋值运算符需要设为虚函数吗

ChatGPT

在一般情况下，重载赋值运算符可以不需要设置为虚函数。因为在赋值时，只会调用对象自身的赋值运算符，而不会调用到其派生类的赋值运算

符。但是，在一些特殊情况下，如果需要用基类指针或引用指向派生类对象，并且需要通过基类指针或引用来赋值，那么就需要将赋值运算符设

置为虚函数。这样就可以保证在通过基类指针或引用赋值时，会调用到相应的派生类赋值运算符，从而保证正确的赋值行为。

### 64 如果基类和派生类都重载了赋值运算符，那么派生类调用赋值运算符会发生什么？

如果派生类重载了赋值运算符，那么派生类对象调用赋值运算符时会调用派生类自己的赋值运算符。但是，派生类的赋值运算符可以在其实现中

显式地调用基类的赋值运算符，以便在执行派生类特有的赋值操作之前完成对基类成员的赋值。

### 65  bool isFull() const { return top == MAX - 1; }是内联函数吗，没有使用关键字inline

ChatGPT

2 / 2

是的，这个函数被定义在类定义内部，且在类中被声明为 const 成员函数，因此它的定义隐式地被认为是内联函数，不需要使用 inline 关键字

进行显式声明。

在类定义内部定义的成员函数会被编译器自动视为内联函数，除非编译器认为不合适，比如函数体太大、递归调用等情况，这时编译器可能会忽

略 inline 关键字并将该函数作为普通函数来处理。但通常情况下，只要满足一定的条件，类定义内部定义的成员函数都可以被视为内联函数。

### 66

 template<typename T>

class Stack

{

private:

 enum { MAX = 10 };

 T items[MAX];

 int top;

public:

 Stack();

 bool isEmpty() const;

 bool isFull() const { return top == MAX - 1; }

 bool push(const T& cs);

 bool pop(T& cs);

}

### push是模板函数吗？

ChatGPT

push() 不是一个模板函数，因为它只使用了 Stack 类的模板参数 T。如果 push() 函数需要使用另一个类型作为模板参数，则它应该被声明为

模板函数。

因此，push() 函数是一个普通的成员函数，可以像普通成员函数一样定义在类的头文件中，也可以在类的头文件中声明，在类的源文件中定义。

### 67 

public:

 Stack();

 bool isEmpty() const;

 template<typename G>

 bool isFull() const { return top == MAX - 1; }

 bool push(const T& cs);

 bool pop(T& cs);

} 

### template<typename G>放在这里合适吗？

ChatGPT

不太合适。在类的声明中定义模板函数的模板参数会使代码更难以理解，并且通常会引起编译器错误。在类声明中使用 template 关键字只适用

于类模板的声明本身，而不是模板函数。

如果您需要定义模板函数，最好将其定义为类模板的友元函数，或将其定义在类模板的外部。

### 68 模板类显式特化时，普通成员函数的显式特化怎么做？

In C++, you cannot explicitly specialize individual member functions of a class template outside of the class definition. 

Instead, you need to explicitly specialize the entire class template.

### 69 模板类的普通成员函数的定义应当放在哪里？

最好放在模板类所在的头文件。如果将它们放在单独的源文件，那么头文件需要在结尾之前包含该源文件

### 70 单参数构造函数是复制构造函数吗？

单参数构造函数的隐式转换不是复制构造函数。它们是两种不同的构造函数。

单参数构造函数是指只接受一个参数的构造函数。当这样的构造函数未被声明为 explicit 时，它允许隐式转换。这意味着编译器可以自动

地使用这个构造函数将一个给定类型的值转换为类类型的对象。

例如，假设我们有一个类 MyClass，它有一个单参数构造函数 MyClass(int x)。如果我们在代码中写下 MyClass myObject = 10;，编译器

会自动地使用单参数构造函数将整数值 10 转换为 MyClass 类型的对象。

复制构造函数是一种特殊的构造函数，它接受一个同类型对象的引用作为参数。它用于创建一个新对象，该对象是对给定对象的副本。复制

构造函数通常用于初始化新对象，或者在按值传递对象时复制对象。

总之，单参数构造函数的隐式转换和复制构造函数是两种不同的构造函数。前者用于将给定类型的值转换为类类型的对象，后者用于创建一

个新对象，该对象是对给定对象的副本。

### 71 初始化列表单个括号不能传入多个参数吗

ChatGPT

初始化列表单个括号只能传入一个参数，如果需要传入多个参数，可以使用花括号 {} 来初始化。例如：

c++

Copy code

class Example {

public:

  Example(int x, int y) : arr{x, y} {}

private:

  std::valarray<int> arr;

};

在上面的例子中，通过花括号 {} 来初始化 arr 成员变量，传入了两个参数。

### 72 Pair() :years(), bottles() {}是默认构造函数吗？

ChatGPT

是的，这是一个默认构造函数，因为它没有参数。它初始化了 years 和 bottles 的值为它们所属类型的默认值。

场景：对象赋值、引用传参

### 73 类的对象的赋值在没有重载的情况下是复制成员吗

是的，在没有重载赋值运算符的情况下，类对象之间的赋值是通过成员赋值（memberwise copy）实现的，即将一个对象的成员逐一赋值给另

一个对象的对应成员1。这个过程也被称为浅拷贝（shallow copy）2。

需要注意的是，当类中有指针成员时，浅拷贝可能会导致问题。因为它只复制了指针的值，而不是指向的内容，所以两个对象中的指针将指

向同一个地址。这样，在析构对象时，会连续两次释放同一块内存区域，从而导致程序异常2。因此，在这种情况下，需要重载赋值运算符以

实现深拷贝（deep copy）2。

### 74 将一个类的对象的引用赋值给另一个对象，也是复制成员吗

不，将一个类的对象的引用赋值给另一个对象并不会复制成员。引用只是为一个已存在的对象起了另一个名字，它本身并不是一个对象。因

此，当您将一个类的对象的引用赋值给另一个对象时，您只是让这两个对象指向同一个内存地址，而不是复制成员。

75 将一个对象以引用传参的方式，在函数中将该参数赋值给对象，是复制成员吗

是的，当您将一个对象以引用传参的方式传递给函数，并在函数中将该参数赋值给另一个对象时，会复制成员。这个过程与直接将一个对象

赋值给另一个对象是一样的。如果没有重载赋值运算符，那么这个过程是通过成员赋值（memberwise copy）实现的，即将一个对象的成员逐

一赋值给另一个对象的对应成员。

### 76 引用传参，传进函数的是这个类的对象的引用吗

是的，当您将一个对象以引用传参的方式传递给函数时，传递的是这个类的对象的引用（注意传递的不是该对象的指针）。引用只是为一个

已存在的对象起了另一个名字，它本身并不是一个对象。因此，当您将一个对象以引用传参的方式传递给函数时，您只是将这个对象的别名

传递给了函数。在函数中，您可以通过这个别名来访问和修改这个对象。

### 77 引用传参，在函数中取参数地址赋值给指针，没有发生成员赋值吗

是的，当您将一个对象以引用传参的方式传递给函数，并在函数中将该参数的地址赋值给指针时，不会发生成员赋值。在这种情况下，您只

是将指针指向了这个对象的内存地址，而不是复制成员。

### 78 私有继承中，派生类怎么初始化基类的私有属性？

在私有继承中，如果派生类需要对基类的成员变量进行初始化，可以在派生类的初始化列表中调用基类的构造函数，并传递参数来初始化基

类的成员变量。

class Base {

private:

  int privateMember;

public:

  Base(int value) : privateMember(value) {}

};

class Derived : private Base {

public:

  Derived(int value) : Base(value) {}

};

因为私有继承不能直接访问基类的私有属性（只能通过基类接口访问），所以Derived(int value) : privateMember(value)这样写是错误的

### 79 将复制构造函数和重载赋值运算符申明在private区域有什么好处？（场景：队列类的定义）

将复制构造函数和重载赋值申明在 private 中，可以防止编译器自动生成默认的复制构造函数和重载赋值操作符，从而限制了该类的对象进行

拷贝构造和赋值操作，增加了类的安全性。

如果不将复制构造函数和重载赋值操作符申明为 private，编译器会默认生成一个“浅拷贝”的复制构造函数和重载赋值操作符，它们会将对象

的成员变量逐个拷贝给新的对象，这样就会导致两个对象共享同一块内存空间，对一个对象的修改会影响到另一个对象，从而破坏了封装性和安

全性。在某些情况下，如果对象中包含指针等动态分配的内存，浅拷贝还可能导致内存泄漏或者段错误等问题。

因此，在设计类的时候，如果不希望对象进行拷贝构造和赋值操作，可以将复制构造函数和重载赋值操作符申明为 private 或删除它们，从而

提高类的安全性和封装性。

### 80 抽象类A：virtual ~A() =0;可以不提供定义吗？

ChatGPT

不可以，如果一个类中包含纯虚析构函数，那么它本身就是抽象类。当抽象类被用作其他类的基类时，如果没有为该抽象类的纯虚析构函数提供

定义，则会导致链接错误。因此，当类中存在纯虚析构函数时，必须为它提供一个定义。虽然该函数不需要具体实现，但需要提供一个空函数体

。例如：

css

Copy code

class A {

public:

​    virtual ~A() = 0;

};

A::~A() {}

### 81 如果一个抽象类只有析构函数是纯虚函数，那么它的派生类是抽象类吗？

如果派生类不申明其他纯虚函数，那么无论是否定义析构函数，派生类都不是抽象类。当派生类未重写虚析构函数，编译器会自动生成一个析构

函数，该析构函数调用基类的析构函数，无论如何，派生类都给纯虚函数做出了定义，所以不是抽象类，可以实例化。

### 82 A是抽象类，B1和B2是A的虚继承派生类，C继承了B1和B2，那么C保留了几个基类对象？

一个，虚继承只保留一个基类对象。

### 83 保护成员和私有成员和公有成员的区别：

在C++中，类成员可以是公有的、私有的或保护的。这三种访问控制方式的主要区别在于它们对于类内外部代码的可访问性不同：

1. 公有成员：

公有成员可以被类内外的任何代码访问。通常在类的接口中声明公有成员，以便类的用户可以使用这些成员。

2. 私有成员：

私有成员只能在类的内部访问，类的外部代码无法访问私有成员。私有成员通常用于实现类的内部功能，隐藏实现细节，防止外部代码不恰

当地访问和修改这些数据。

3. 保护成员：

保护成员在类的内部和派生类中可以访问，但在类外部不可访问。保护成员通常用于在继承中共享数据和行为。派生类可以访问保护成员，

以便扩展和修改基类的实现。

总的来说，访问控制的目的是为了封装类的实现细节，隐藏内部数据和方法的实现，从而提高代码的安全性和可维护性。公有成员提供了类的接

口，使类的用户可以访问类的功能，而私有成员和保护成员则隐藏了类的内部细节，避免外部代码不恰当地访问和修改数据。

公有成员可以在任何地方使用：比如Queue q=Queue(QUEUE:QSIZE)，其中QSIZE是申明在公有区域的静态常量，通过类限定符可以直接访问；

私有成员只能在编写类的时候使用，只能在本类中使用，派生类不能直接访问

保护成员不能像公有成员那样使用类限定符来访问，但是在公有继承的时候，派生类对象可以使用保护函数来操作私有成员。（如果把保护函数

写成公有函数，那么私有成员就丧失了意义。将类的私有属性的操作权放到公有区域会导致该属性可以被任何代码直接访问和修改，违背了封装

的原则，增加了代码的耦合性，降低了代码的可维护性和安全性。

### 84 用指向对象的指针和直接使用对象来调用对象的方法有什么区别？

使用指向对象的指针调用对象的方法和直接使用对象调用方法的主要区别在于，当使用指针调用虚函数时，将发生动态绑定。这意味着，如果指

针指向派生类对象，则将调用派生类中的虚函数实现。而直接使用对象调用虚函数时，将调用该对象所属类中的虚函数实现。

例如，假设有一个基类`Base`和一个派生类`Derived`，它们都有一个虚函数`foo()`。如果我们有一个`Base`类型的指针`pBase`，它指向一个`

Derived`类型的对象，那么当我们调用`pBase->foo()`时，将调用`Derived`类中的`foo()`实现。但是，如果我们直接使用一个`Base`类型的对

象调用`foo()`，则将调用`Base`类中的`foo()`实现。

class Base {

public:

​    virtual void foo() { cout << "Base::foo()" << endl; }

};

class Derived : public Base {

public:

​    void foo() override { cout << "Derived::foo()" << endl; }

};

int main() {

​    Base b;

​    Derived d;

​    Base* pBase = &d;

​    b.foo(); // 输出 "Base::foo()"

​    pBase->foo(); // 输出 "Derived::foo()"

​    return 0;

}

### 85 函数名是指针吗？

在C语言中，函数名是一个指向函数的指针。当你使用函数名时，它会自动转换为指向该函数的指针。例如，在下面的代码中，函数名my_

function被自动转换为指向该函数的指针：

csharp

Copy code

void my_function() {

​    printf("Hello, world!\n");

}

int main() {

​    void (*p)() = my_function;  // 将函数名赋值给指向函数的指针变量

​    p();  // 调用指针指向的函数

​    return 0;

}

在这个例子中，my_function被自动转换为指向该函数的指针，可以通过将它赋值给一个指向函数的指针变量来使用它，然后使用该指针调用

函数。因此，函数名可以看作是指向函数的指针。

### 86 虚函数表是什么？

ChatGPT

虚函数表（Virtual Function Table，简称vtable）是C++中用于实现动态多态性的重要机制之一。当一个类中包含虚函数时，编译器会为这

个类生成一个虚函数表，其中存储了这个类的虚函数的地址。虚函数表是一个数组，其中每个元素都是一个指向虚函数的指针。每个包含虚

函数的类都有一个唯一的虚函数表，它被存储在对象的内存布局中。

当一个对象被定义为指向基类的指针或引用，并且通过这个指针或引用调用虚函数时，程序会使用对象的虚函数表来确定要调用哪个函数。

编译器会在对象内存中存储一个指向虚函数表的指针，这个指针指向类的虚函数表。程序通过这个指针来查找要调用的虚函数，并将控制权

转移给相应的函数。

在派生类中，如果它重写了基类中的虚函数，那么它也会生成一个自己的虚函数表，并在其中存储它所重写的虚函数的地址。当一个派生类

对象被定义为指向基类的指针或引用，并通过这个指针或引用调用虚函数时，程序会在派生类的虚函数表中查找要调用的函数，如果找不到

就会在基类的虚函数表中查找。这种机制保证了程序能够正确地调用派生类的虚函数。

### 87 申明、声明和定义的区别

申明=声明，用于告诉编译器一个标识符的类型，但并不提供它的名称和存储空间。申明通常在头文件中进行，用于向程序的其他部分提供类

型信息。

定义：为一个标识符分配存储空间并赋初值的过程。对于变量、函数或类等标识符，定义通常包括声明的同时进行，也就是同时提供标识符

的名称、类型、存储空间和初值。例如：

### 88 类的公共非静态方法怎么在类外访问？

要在类外部访问类的公共非静态方法，需要先创建类的对象（实例），然后使用该对象来调用方法。

### 89 构造函数使用explicit修饰的作用

ChatGPT

在C++编程语言中，当一个类的构造函数使用 explicit 关键字修饰时，它具有以下作用：

防止隐式转换：explicit 关键字用于禁止隐式类型转换。如果一个构造函数被声明为 explicit，那么在使用该构造函数时，编译器将不会

执行隐式类型转换。这意味着只有显式调用构造函数，且参数类型完全匹配，才能创建对象。

明确表达意图：使用 explicit 关键字可以明确地表达构造函数的意图。它提醒使用该构造函数的程序员，需要显式地创建对象，以避免可

能导致误解或错误的隐式转换。

class MyClass {

public:

​    explicit MyClass(int value) {

​        // 构造函数的实现

​    }

};

void function(const MyClass& obj) {

​    // 函数的实现

}

int main() {

​    MyClass obj1(10);  // 直接调用构造函数创建对象

​    function(obj1);   // 传递对象作为参数，不会发生隐式类型转换

​    // MyClass obj2 = 20;  // 编译错误，禁止隐式类型转换

​    MyClass obj2 = MyClass(20);  // 显式调用构造函数，创建对象

​    function(obj2);              // 传递对象作为参数，不会发生隐式类型转换

​    return 0;

}

在上述示例中，构造函数 MyClass(int value) 被声明为 explicit，因此在创建对象时，必须使用显式调用。如果尝试使用隐式类型转换，

例如 MyClass obj2 = 20;，编译器将产生错误。

通过使用 explicit 关键字，可以避免因隐式类型转换而导致的潜在问题，同时提高代码的可读性和可维护性。

显示转换（Explicit Conversion）：也称为强制转换（Type Casting）。

隐式转换（Implicit Conversion）：也称为自动转换（Automatic Conversion）或隐式类型转换（Implicit Type Conversion）。

### 90 STL函数和STL方法的区别?

STL函数（STL functions）：这通常指的是算法（algorithms）部分中的函数。STL算法是对容器（containers）和迭代器（iterators）进行

操作的函数，它们独立于特定的容器类型，并提供了各种常用的操作，如排序、查找、变换等。例如，std::sort、std::find、std::

transform等都是STL函数的例子。

STL方法（STL methods）：这通常指的是容器类（container classes）中的成员函数。STL容器类是用于存储和管理元素的数据结构，它们通

常提供一系列成员函数来操作容器本身，如插入、删除、访问元素等。例如，std::vector 的 push_back、pop_back、at 等都是STL方法的例

子。

### 91 string对象是在哪里分配的内存？

具体地说，std::string 类内部维护了一个指针，这个指针指向动态分配的字符数组（缓冲区），用来存储字符串的字符序列。这个字符数组

通常是在堆上分配的。

当你创建一个 std::string 对象时，其大小是固定的，它包含了一些额外的数据成员，如长度信息和指向字符数组的指针。这些数据成员被存

储在对象本身所占据的栈空间中。

而字符数组本身的内存是在堆上动态分配的，std::string 对象会负责管理这块内存。它会在适当的时机分配、释放和重新分配内存，以适应

字符串的长度变化。

总结起来，std::string 对象本身是在栈上分配的，而字符串的字符数组是在堆上动态分配的。这种设计使得 std::string 对象的创建和销毁

更加高效，并且可以自动管理字符串内存的分配和释放，减轻了手动管理内存的负担。

### 92 int i=0;auto_ptr<int>pr(&i);正确吗

ChatGPT

No, the usage of auto_ptr in the given code snippet is not correct.

The auto_ptr class was a part of the Standard Library until C++11 but has been deprecated since then. It is recommended to 

use unique_ptr instead, which provides similar functionality but with improved safety and flexibility.

Additionally, it is important to note that taking the address of a local variable (i in this case) and assigning it to a 

smart pointer is not a recommended practice. Smart pointers, like unique_ptr, are typically used for managing the ownership 

of dynamically allocated objects.

Here's an updated version of your code using unique_ptr:

cpp

Copy code

\#include <iostream>

\#include <memory>

int main() {

​    int i = 0;

​    std::unique_ptr<int> pr(new int(i));

​    // Access the value through the smart pointer

​    std::cout << *pr << std::endl;

​    return 0;

}

### 93 如果这样做了会怎么样

ChatGPT

如果使用以下方式进行编写：

cpp

Copy code

int i = 0;

std::auto_ptr<int> pr(&i);

这种用法是不正确的，会导致不确定的行为和潜在的问题。

std::auto_ptr 是 C++98 标准库中提供的智能指针之一，用于管理动态分配的对象。然而，std::auto_ptr 存在一些问题，其中之一是在转移

所有权时存在风险。在此示例中，将 &i（即 i 的地址）传递给 std::auto_ptr 构造函数，会导致 std::auto_ptr 认为它现在拥有 i 的所有

权。这样做会导致以下问题：

std::auto_ptr 的析构函数会尝试释放所管理的内存，但是传递给 std::auto_ptr 构造函数的地址 &i 是一个指向自动存储区（栈）的地址，

不应由 std::auto_ptr 负责释放。这可能导致未定义的行为和程序崩溃。

当 std::auto_ptr 被销毁时，它会尝试删除所管理的指针。然而，在这种情况下，指针指向的是一个位于栈上的对象，而不是通过 new 运算

符分配的动态内存。尝试删除栈上的对象将导致未定义的行为。

由于这些问题，使用 std::auto_ptr 来管理自动存储区的对象是不安全的，而且在 C++11 及以后的标准中已被弃用。

推荐使用更现代的智能指针，如 std::unique_ptr 或 std::shared_ptr，来管理动态分配的对象，而不是尝试将其用于自动存储区的对象。

### 94 std::sort怎么实现的

ChatGPT

C++ 标准库中的 std::sort 函数使用了一种经典的排序算法，通常是快速排序（Quick Sort）或归并排序（Merge Sort）的变体。

快速排序是一种分治算法，它通过选取一个元素作为基准（通常是数组中的一个元素），将数组分成两个子数组：小于基准的元素子数组和大

于基准的元素子数组。然后，递归地对两个子数组进行排序。最后，将两个子数组合并起来，形成有序的数组。

归并排序是一种分治算法，它将数组递归地分成两个子数组，然后对子数组进行排序，最后将两个有序子数组合并为一个有序数组。归并排序

的关键是合并两个有序数组的过程。

std::sort 函数可能会使用这两种算法的变体，具体的实现取决于实现库。实现 std::sort 的方式可能会根据数组的大小、数据类型等因素而

有所不同，以获得最佳的性能。

C++ 标准库中的 std::sort 函数通常是高度优化的，并具有较好的时间复杂度。它能够在大多数情况下以很高的效率对数组进行排序。

需要注意的是，C++ 标准库中的 std::sort 函数是针对可随机访问容器（如数组、向量等）的排序，对于其他类型的容器（如链表）则需要使

用相应的排序函数或算法。

### 95 指针和迭代器的区别

ChatGPT

指针和迭代器在某些方面是相似的，但也存在一些差异。

相似之处：

都可以用于访问容器（如数组、向量等）中的元素。

都可以用于指示容器中的位置。

都可以进行递增和递减操作，以便在容器中移动。

不同之处：

类型不同：指针是原生 C++ 类型，而迭代器是封装在容器类中的对象。

功能不同：迭代器通常提供更多的功能和操作，例如可以通过迭代器进行范围遍历、访问元素的值和属性等。指针的功能相对较少，主要用于指示

位置和进行简单的指针算术运算。

容器依赖：迭代器是与容器类紧密关联的，每种容器都有自己特定的迭代器类型。指针可以用于访问任何连续的内存块，不一定局限于容器。

在 C++ 标准库中，很多算法和容器都使用迭代器作为参数，因为迭代器提供了更高级的功能和通用性。但是，指针仍然是一种有效的方式来访问

和操作数组等连续内存块。实际上，指针可以被视为最简单的迭代器形式。

总的来说，指针和迭代器在某些方面相似，但迭代器通常更具灵活性和功能性，特别是在与标准库算法和容器一起使用时。

### 96 可以使用std::sort对set排序吗

ChatGPT

是的，可以使用 std::sort 对 std::set 进行排序。但请注意，std::set 是一种基于红黑树实现的有序容器，它会自动维护元素的有序性。因此

，对 std::set 使用 std::sort 并不会改变元素的顺序，因为它们已经按照特定的排序准则进行了排序。

如果你想对 std::set 进行排序，并且希望得到排序后的结果，你可以先将 std::set 中的元素复制到一个 std::vector 中，然后对 std::

vector 使用 std::sort 进行排序。下面是一个示例：

### 97 set的顺序是按照什么来的

`std::set` 是 C++ 标准库提供的有序容器，它按照元素的值进行排序。具体来说，`std::set` 内部使用红黑树（Red-Black Tree）数据结构来

实现，这种数据结构能够保持元素的有序性。

在默认情况下，`std::set` 会按照元素的升序进行排序。对于整数类型的元素，例如 `std::set<int>`，元素会按照从小到大的顺序进行排序。

对于字符串类型的元素，例如 `std::set<std::string>`，元素会按照字典序进行排序。

你可以自定义排序准则来创建一个自定义比较函数或函数对象，并将其作为 `std::set` 的模板参数。这样可以按照自定义的排序准则来对元素进

行排序。

以下是一个示例，展示了如何自定义排序准则来创建一个按照元素长度从小到大进行排序的 `std::set<std::string>`：

\```cpp

\#include <iostream>

\#include <set>

\#include <string>

struct LengthComparator {

​    bool operator()(const std::string& str1, const std::string& str2) const {

​        return str1.length() < str2.length();

​    }

};

int main() {

​    std::set<std::string, LengthComparator> mySet;

​    mySet.insert("apple");

​    mySet.insert("banana");

​    mySet.insert("cherry");

​    mySet.insert("date");

​    for (const auto& str : mySet) {

​        std::cout << str << " ";

​    }

​    std::cout << std::endl;

​    return 0;

}

\```

在上述示例中，我们创建了一个自定义的比较函数对象 `LengthComparator`，用于按照字符串的长度进行比较。然后，我们声明一个 `std::set<

std::string>` 对象，并指定比较函数对象 `LengthComparator` 作为第二个模板参数。最后，我们向 `mySet` 插入一些字符串，并遍历输出，

结果会按照字符串长度从小到大进行排序。

运行以上代码，将输出以下结果：

\```

date apple cherry banana

\```

总而言之，`std::set` 的元素顺序是由内部的排序准则决定的，默认情况下是按照元素的值进行升序排序。你也可以自定义比较函数或函数对象

来指定自定义的排序准则。

### 98 为什么release模式比debug模式快

ChatGPT

在软件开发中，通常有两种编译模式：Debug 模式和 Release 模式。这两种模式在性能方面可能会有显著的差异，其中 Release 模式往往比 

Debug 模式更快。

以下是一些常见的原因，解释为什么 Release 模式比 Debug 模式更快：

优化级别：Release 模式会使用更高级别的优化，例如内联函数、循环展开、常量传播等。这些优化会改善代码的执行效率，减少不必要的指令

和函数调用，从而提高程序的性能。

符号表和调试信息：Debug 模式通常会生成符号表和调试信息，以支持调试器和符号级调试。这些额外的信息会增加可执行文件的大小，并对程

序的执行速度产生一定的影响。而 Release 模式不生成这些调试信息，从而减小了可执行文件的大小，并提高了执行速度。

运行时检查和断言：Debug 模式通常会进行更多的运行时检查，例如数组越界检查、空指针检查和断言等。这些检查会增加额外的运行时开销，

并影响程序的性能。而 Release 模式通常会禁用或减少这些运行时检查，以提高执行效率。

编译器优化：Release 模式的编译器会进行更多的优化，例如常量折叠、无用代码删除和循环优化等。这些优化技术可以提高代码的执行效率和

内存利用率，从而提高程序的性能。

需要注意的是，尽管 Release 模式通常会比 Debug 模式更快，但在 Debug 模式下进行调试和错误排查会更方便，因为 Debug 模式保留了更多

的调试信息和运行时检查。因此，在开发和测试阶段，建议使用 Debug 模式进行调试和错误排查；而在正式发布和性能优化阶段，使用 

Release 模式以获得更高的执行速度。

总结而言，Release 模式通过优化级别、减少调试信息和运行时检查等手段，提高了程序的执行效率，从而比 Debug 模式更快。但这种速度的

提升是以牺牲调试和错误排查的便利性为代价的。

### 99 struct的属性默认是public还是private

ChatGPT

在 C++ 中，默认情况下，结构体（struct）中的成员是公有的（public）。这意味着结构体的成员可以在外部访问和修改。

100 vector<shared_ptr<Review>> price_asc = origin;auto it = price_asc.rbegin(),it是什么类型？

ChatGPT

it 的类型是 std::vector<std::shared_ptr<Review>>::reverse_iterator。price_asc.rbegin() 返回的是反向迭代器，表示指向 price_asc 

的最后一个元素的迭代器，因此 it 是 price_asc 中元素逆序遍历的迭代器。

### 100 此时*it是什么？

ChatGPT

*it 表示通过迭代器 it 访问的值。在这种情况下，it 是一个逆序迭代器，它指向 price_asc 中的某个元素（std::shared_ptr<Review> 类型

的智能指针）。通过 *it，您可以获取该智能指针所指向的对象。

如果 std::shared_ptr<Review> 是一个指向 Review 类型对象的智能指针，那么 *it 将返回指向 Review 对象的智能指针。您可以使用 -> 运

算符来访问智能指针所指向对象的成员。

### 101 cin.get()和cin>>的区别

`cin.get()`和`cin>>`是C++中用于从标准输入读取数据的两种不同的方法。

`cin.get()`是一个成员函数，它可以读取单个字符或一行字符串，包括空格和换行符。它的语法如下：

\```cpp

cin.get(char_variable); // 读取单个字符

cin.get(char_array, size); // 读取一行字符串，并存储到字符数组中，最多读取size-1个字符

cin.getline(char_array, size); // 读取一行字符串，并存储到字符数组中，最多读取size-1个字符，遇到换行符停止

\```

使用`cin.get()`时，可以读取包含空格和换行符的数据，它不会忽略它们，而是将它们作为输入的一部分。这使得它在需要处理包含空格的输

入时非常有用。

`cin>>`是一个重载了右移运算符的输入流提取操作符，用于从标准输入读取不包含空格的数据，并将其存储到相应的变量中。它的语法如下：

\```cpp

cin >> variable; // 从标准输入读取数据，并存储到变量中

\```

`cin>>`会忽略输入中的空格和换行符，只读取有效的数据部分。它通常用于读取整数、浮点数、字符串等不包含空格的数据类型。

因此，`cin.get()`适用于读取包含空格和换行符的输入，而`cin>>`适用于读取不包含空格的数据类型。根据具体的需求和输入格式，选择适合

的方法进行输入操作。

### 102 可以用char[] 来进行非文本文件的复制吗？

不能，因为文本方式读取和写入文件会对文件内容进行字符转换，而二进制文件中的某些字符可能无法正确转换或被错误处理。要复制二进制文

件，你需要使用二进制方式打开文件并进行读写操作。你可以在打开文件时指定打开模式为ios::binary来确保以二进制方式进行操作。

string src = "text.pdf";

string dest = "r.pdf";

const int buffersize = 1024;

char buffer[buffersize];ifstream ifs;

ofstream ofs;

ifs.open(src, ios::binary);

ofs.open(dest, ios::binary);

if (!ifs.is_open())

{

​    cout << "Open file failed.\n";

​    exit(EXIT_FAILURE);

}

while (ifs.read(buffer, buffersize))

{

​    ofs.write(buffer, ifs.gcount());

}

cout << "Done.\n";

ifs.close();

ofs.close();

}

### 103 ifstream eof()函数

ChatGPT

ifstream类是C++标准库提供的用于读取文件的输入流类。eof()函数是ifstream类的成员函数之一，用于判断文件读取是否已到达文件末尾。

eof()函数在ifstream对象调用之后，会返回一个bool类型的值，表示当前文件读取位置是否已到达文件末尾。如果返回值为true，则表示文件读

取已到达末尾；如果返回值为false，则表示文件读取尚未到达末尾。

通常情况下，我们会在循环中使用eof()函数来判断文件读取是否已结束，以便正确地处理文件内容。例如，可以将eof()函数与getline()函数结

合使用来逐行读取文件内容，直到文件末尾。

### 104 while (getline(fs, line)) { cout << line << "\n"; }读到文件流的末尾还能再写入吗？

ChatGPT

在使用 getline(fs, line) 从文件流中读取文本行时，如果读取到文件流的末尾，表示已经读取完文件内容，此时文件指针已经指向文件末尾，

无法再直接写入数据到文件流。

如果你想在读取完文件内容后继续向文件中写入数据，你可以关闭文件流并重新以写入模式打开文件流，然后进行写入操作。

### 105 二进制打开文件，不能使用readline吗

ChatGPT

当以二进制模式打开文件时，你不能使用 readline 函数，因为 readline 函数是用于逐行读取文本文件的。

### 106 ofs.write(len_s.c_str(), len_s.size());会自动补一个\0和\n吗？

ChatGPT

在使用 ofs.write(len_s.c_str(), len_s.size()) 写入数据时，它不会自动在末尾补充一个换行符（\n）。 write 函数是以字节为单位进行写

入的，它不会对数据进行解释或添加额外的字符。

### 107 右值是什么?

ChatGPT

右值（rvalue）是指表达式的值，该值可以出现在赋值运算符的右侧。在 C++ 中，右值可以分为以下两种类型：

临时右值（Temporary Rvalue）：临时右值是在表达式求值过程中生成的临时值，通常是由编译器自动生成的。例如，一个数字常量、一个表达

式的计算结果或一个匿名对象等都属于临时右值。

将亡值（将要被移动的值，也称为 xvalue）：将亡值是指将要被移动的对象的值，通常是在对象即将销毁之前使用 std::move() 函数转换得到

的。将亡值表示可以被移动或转移所有权的对象，例如，一个即将被销毁的对象、一个右值引用或通过 std::move() 转换得到的对象等。

右值具有特定的属性，例如可以被移动、可以被转移所有权等。在 C++11 及更高版本的标准中，引入了右值引用（rvalue reference）的概念，

使得可以更有效地管理右值的生命周期和资源。右值引用通过 && 表示，用于绑定到右值，并可以在移动语义和完美转发等场景中发挥重要作用

。

通过理解右值和左值的区别，可以更好地理解和使用 C++ 中的移动语义、完美转发以及利用临时对象的优化等特性。

### 108 派生类的虚函数将隐藏基类的虚函数什么意思?

当派生类中定义了与基类中的虚函数具有相同名称但特征标（包括参数类型、返回类型和常量性）不匹配的函数时，派生类的虚函数将隐藏基类

的虚函数。这意味着当您通过基类指针或引用调用派生类虚函数时，实际执行的是派生类中定义的函数，而不是基类中的函数。这种情况下，基

类的虚函数被隐藏，无法被直接调用，编译器将发出错误。

为了解决这个问题，您可以使用 using 声明将基类的虚函数重新引入派生类的作用域，使其可见并重新启用动态绑定。通过这样的修改，基类的

虚函数将重新可见，并且在通过基类引用调用时将正确地执行派生类中的重写函数。

### 109 int k{ 1.1 };可以通过编译吗？

在您提供的代码中，存在一个类型不匹配的问题。int k{ 1.1 }; 尝试使用列表初始化方式将浮点数值 1.1 分配给整型变量 k。

在 C++ 中，列表初始化具有严格的类型匹配要求。由于 1.1 是一个浮点数字面量，而变量 k 是一个整型变量，它们的类型不匹配。因此，这段

代码将导致编译错误。

### 110 double x{ 8.8 };和double x={8.8}等价吗？

ChatGPT

是的，double x{ 8.8 }; 和 double x = {8.8}; 是等价的，它们都使用了列表初始化（uniform initialization）的语法来定义和初始化一个

名为 x 的 double 类型变量，并将值 8.8 分配给它。

在 C++ 中，使用大括号 {} 进行列表初始化可以提供更严格的初始化语义，以避免一些可能出现的隐式类型转换和窄化转换（narrowing 

conversions）。

无论是使用大括号 {} 进行列表初始化，还是使用等号 = 进行复制初始化，对于简单的数值类型，如 double，它们在大多数情况下是等价的，

都可以正确地将初始值分配给变量。

综上所述，double x{ 8.8 }; 和 double x = {8.8}; 是等价的语句，都会将值 8.8 分配给 x 变量，并将其初始化为 8.8。

### 111 void f(const int& a);void f(int& a);int a=0;f(a+1)调用的是哪个?

ChatGPT

根据函数重载的规则，当存在多个函数具有相同名称但参数类型不同的函数声明时，编译器会根据实际参数的类型选择最匹配的函数进行调用。

在这种情况下，调用 f(a+1) 时，参数是表达式 a+1，其中 a 是一个整数变量。

根据函数重载的规则，编译器会优先选择与实际参数类型最匹配的函数进行调用。在这里，a+1 的结果是一个临时的整数值，而临时值不能被绑

定到非常量引用类型的参数。因此，最匹配的函数是 void f(const int& a)，它接受一个对常量整数的引用。

因此，f(a+1) 调用的是 void f(const int& a)。

一般而言，非const 左值形参和左值实参匹配，非const右值形参与右值实参匹配，const左值形参可以接受左值实参和右值实参。编译器优先选

用前两种匹配方式。

将左值传给const 左值引用形参，参数被初始化为左值

将右值传给const 左值引用形参，参数被初始化为右值的临时拷贝

### 112 存在const 右值引用这种类型吗？

ChatGPT

在 C++ 中，不存在直接的语法来声明 const 右值引用。右值引用本身就是一种用于绑定右值的引用类型，不需要使用 const 修饰符来表示其

常量性质。

由于右值引用的主要用途是支持移动语义和完美转发，它们通常用于修改或获取右值对象的资源。因此，将右值引用声明为 const 是没有意义

的，因为 const 表示对象是不可修改的。

例如，以下代码尝试声明一个 const 右值引用：

cpp

Copy code

const int&& rvalueRef = 42;  // 错误！不允许声明 const 右值引用

上述代码将导致编译错误，因为 const 右值引用的语法是不合法的。

### 113 右值只能传给右值引用或者const 左值引用吗？

ChatGPT

是的，右值通常只能传递给右值引用或者 const 左值引用。

右值引用是对右值进行引用的一种引用类型，通过使用 && 修饰符声明。右值引用主要用于移动语义和完美转发。

const 左值引用是对常量左值进行引用的引用类型，通过使用 const 关键字和 & 修饰符声明。const 左值引用用于接受常量左值的引用。

右值可以被绑定到右值引用，因为右值引用的目的就是为了能够处理右值。同时，右值也可以被绑定到 const 左值引用，因为 const 左值引用

可以接受常量左值和右值。

然而，非 const 左值引用不能绑定到右值，因为非 const 左值引用要求绑定的对象具有持久的存储，而右值通常是临时的、没有命名的对象。

总结起来，右值可以传递给右值引用或者 const 左值引用，而非 const 左值引用不能直接绑定到右值。

### 114 在有移动构造函数的情况下 Cpmv e(c1 + c2);执行了移动构造函数吗？

ChatGPT

在有移动构造函数的情况下，如果执行了类似于Cpmv e(c1 + c2);的语句，是否调用移动构造函数取决于编译器的优化和实现细节。

在这个语句中，c1 + c2产生了一个临时对象，该临时对象作为参数传递给Cpmv类的构造函数。如果编译器能够进行RVO（返回值优化）或NRVO

（命名返回值优化），临时对象可能直接被构造在e上，而不需要调用移动构造函数。这种情况下，移动构造函数不会被执行。

然而，如果编译器无法进行优化或者没有启用优化选项，那么移动构造函数会被调用，用于将临时对象的状态移动到目标对象e中。

需要注意的是，编译器的行为可能因为编译器版本、编译选项以及代码的具体实现而有所不同。因此，在这种情况下，最好查看生成的汇编代码

或者参考编译器的文档来确定移动构造函数是否被调用。

### 115 如何在编译时判断参数是否是数值类型？

template<typename T, typename... Args>

long double sumValue(const T& value, const Args&... args)

{

 if constexpr (std::is_arithmetic<T>::value)

  return static_cast<long double>(value) + sumValue(args...);

 else

  return sumValue(args...);

}

在上面的示例中，我们使用了if constexpr语句来进行条件编译。if constexpr是C++17引入的语法，它在编译时根据条件判断是否执行

代码块。如果条件为真并且条件中的表达式可以在编译时求值，那么对应的代码块将在编译时执行；否则，对应的代码块将在运行时被

丢弃。

### 116 可变参数模板函数和普通函数可否构成重载？

是的，可变参数模板函数和普通函数可以构成重载关系。C++中，函数重载是指在同一作用域内，函数名相同但参数列表不同的多个函数。可变参

数模板函数可以接受任意数量和类型的参数，而普通函数则具有固定的参数列表。

当调用函数时，编译器会根据参数的数量和类型来匹配最合适的函数。如果存在多个函数名相同但参数列表不同的函数，编译器会根据参数的具体

情况选择匹配的函数进行调用。这就是函数重载的机制。

对于可变参数模板函数和普通函数的重载，编译器会根据实际传递的参数来确定调用哪个函数。如果传递的参数数量和类型能够完全匹配可变参数

模板函数的参数列表，则调用可变参数模板函数；如果存在一个普通函数的参数列表能够精确匹配传递的参数，那么将调用普通函数。在重载解析

过程中，编译器会优先选择最佳匹配的函数。

需要注意的是，函数重载的规则是在同一作用域内进行匹配，如果可变参数模板函数和普通函数位于不同的作用域，它们将不会构成重载关系。

### 117 在头文件直接定义函数会发生什么？

ChatGPT

在头文件中直接定义函数会导致函数的定义在每个包含该头文件的源文件中都出现，从而引发重定义错误。这是因为头文件通常会被多个源文件包

含，每个源文件都会将头文件的内容包含进去，包括函数的定义部分。

当多个源文件都包含了相同的函数定义时，编译器会认为存在多个相同的函数定义，从而导致重定义错误。这是违反了C++的单一定义规则（One 

Definition Rule）的。

因此，在头文件中通常只应该包含函数的声明而不是定义。函数的定义应该放在源文件中，然后通过包含头文件来引用函数的声明。这样可以避免

重定义错误，并确保每个函数只有一个定义。

### 118 如果是模板函数，可以直接定义在头文件吗？

ChatGPT

是的，对于模板函数，可以将其定义直接放在头文件中。这是因为模板函数的定义需要在编译时根据实际使用的模板参数进行实例化，而编译器需

要在使用模板函数的源文件中看到其定义才能进行实例化。

将模板函数的声明和定义都放在头文件中，可以确保在每个使用该模板函数的源文件中都能看到其定义，并且能够正确实例化模板函数的不同版本

。

因此，对于模板函数，通常将其声明和定义都放在同一个头文件中是常见的做法。这样可以方便其他源文件包含该头文件并使用模板函数，而无需

在每个源文件中单独编写模板函数的定义。